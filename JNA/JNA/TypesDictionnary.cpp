/** @file
 *
 * Body for TypesDictionnary class
 */

#include <fstream>
#include "Utils/Output.h"
#include "Utils/Utils.h"
#include "Utils/Parameters.h"
#include "JNA/Struct.h"
#include "JNA/Enum.h"
#include "JNA/NativeType.h"
#include "JNA/Callback.h"
#include "JNA/TypesDictionnary.h"

using std::string;
using std::ofstream;
using nsModules::Module;
using nsJNA::Type;
using nsUtils::Output;
using nsUtils::createJavaFileName;
using nsUtils::createPackageTree;
using nsUtils::Parameters;
using nsC::Param;
using nsJNA::Struct;
using nsJNA::Enum;
using nsJNA::NativeType;
using nsJNA::Callback;

#define TYPESDICTIONNARY nsJNA::TypesDictionnary

TYPESDICTIONNARY::TypesDictionnary()
{
	std::cout << "I'm in constructor of TypesDictionnary !!" << std::endl;
    addBaseTypes();
}

TYPESDICTIONNARY::~TypesDictionnary()
{
    for (Type::map::iterator iterator(mTypes.begin());
         iterator != mTypes.end();
         ++iterator)
        delete iterator->second;
}

bool TYPESDICTIONNARY::addModules(Module::vector& modules)
{
    Output& output(Output::getInstance());

    output.startProgress((int) modules.size(), 
                         "STEP 3/x Fetching data types");
    for (Module::vector::const_iterator iter(modules.begin());
         iter != modules.end();
         ++iter)
    {
        output.progress(string("Fetching data types from \"") + 
                        iter->getModuleName() + 
                        "\"");
        if (!addModule(*iter)) {
            output.endProgress(true);
            ERR << "Error while adding \"" << iter->getModuleName()
                << "\" to the dictionnary\n";
            return false;
        }
    }
    output.endProgress();
    return true;
}

bool TYPESDICTIONNARY::convertToJava(void)
{
	std::cout << "hehe" << std::endl;
    Output& output(Output::getInstance());

    output.startProgress((int) mTypes.size(), 
                         "STEP 4/x Converting data types");
    for (Type::map::iterator iterator(mTypes.begin());
         iterator != mTypes.end();
         ++iterator)
    {
        output.progress(string("Converting \"") +
                        iterator->first +
                        "\"");
		std::cout << "iterator->first : " << iterator->first << "and iterator->second : " << iterator->second << std::endl;
        if (!iterator->second->convertToJava()) {
            output.endProgress(true);
            return false;
        }
    }
    output.endProgress();

    return true;
}

bool TYPESDICTIONNARY::outputJava(void)
{
    string javaPath(
            Parameters::getInstance().getJavaSrcDir());
    bool dryRun(Parameters::getInstance().isDryRun());
    Output& output(Output::getInstance());

    if (!dryRun)
        output.startProgress((int) mTypes.size(), 
                             "STEP 5/x Writting Java class for types");
    else
        OUT << " ========== DRY RUN ==========\n"
               "STEP 5/x Writting Java class for types\n";
        
    for (Type::map::const_iterator iterator(mTypes.begin());
         iterator != mTypes.end();
         ++iterator) {
        const Type* obj(iterator->second);
        if (obj->needWriting()) {
            string filePath = 
                createJavaFileName(javaPath,
                                   obj->getFullPackageName(),
                                   obj->getBaseJavaName());
            if (dryRun) {
                OUT << "Writting Java class \"" << obj->getBaseJavaName()
                    << "\" into \"" << filePath << "\"\n";
            }
            else
            {
                DEBUG(3) << "Output Java code for \"" << iterator->first 
                         << "\" into \"" << filePath << "\"\n";
                output.progress(string("Writting \"") + 
                                       obj->getBaseJavaName() +
                                       "\"");
                createPackageTree(javaPath, obj->getFullPackageName());
                ofstream outputFile(filePath.c_str());
                outputFile << 
                    "/* code generated by JNAConvert -- DO NOT EDIT */\n";
                obj->writeJava(outputFile);
                outputFile.close();
            }
        }
        else if (!dryRun)
            output.progress(string("Skipping \"") + 
                                   obj->getBaseJavaName() +
                                   "\"");
    }
    if (!dryRun)
        output.endProgress();
    return true;
}

Type* TYPESDICTIONNARY::getType(const string& CType, bool returnValue) const
{
    Type::map::const_iterator iter;
    string realCType(CType);
    bool skipTransform(false);
    // really special case...
    if (realCType == "const char *")
        skipTransform = true;
    
    if (!skipTransform) {
        if (realCType.find("const ") == 0 || realCType.find("const_") == 0)
            realCType.erase(0, 6);

        if (realCType == "char *" && !returnValue)
            realCType = "void *";
    }

    iter = mTypes.find(realCType);
    if (iter != mTypes.end())
        return iter->second;
    else {
        ERR << "Tried to fetch unknown CType:\""
            << CType
            << "\"\n";
        return NULL;
    }
}

Type* TYPESDICTIONNARY::getType(const Param& param, bool returnValue) const
{
    return getType(param.getCType(), returnValue);
}

void TYPESDICTIONNARY::addBaseTypes()
{
    NativeType::createNativeTypes(mTypes);
}

bool TYPESDICTIONNARY::addModule(const Module& module)
{
    // FIXME typedef should be handled sooner
    if (!NativeType::createTypedef(module.getTypedefs(), mTypes)) 
        return false;
    if (!Struct::create(module, *this, mTypes)) return false;
    if (!Enum::create(module, mTypes)) return false;
    if (!Callback::create(module, *this, mTypes)) return false;
    return true;
}

#undef TYPESDICTIONNARY

