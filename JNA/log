JNAConvert - C header to Java class convertion, ALPHA
by: Gabriel Paul "Cley Faye" Risterucci
Locating C headers...
Building file list...
Using header path:"Headers/"
Entering directory ""
Using path:"Headers/"
Got entry for:".."
Got entry for:"kab"
Entering directory "kab/"
Using path:"Headers/kab/"
Got entry for:"sign.h"
Adding file "sign.h"
Adding module source:"Headers/kab/sign.h" >> "kab/.sign.h"
Got entry for:".."
Got entry for:"kdf.h"
Adding file "kdf.h"
Adding module source:"Headers/kab/kdf.h" >> "kab/.kdf.h"
Got entry for:"err.h"
Adding file "err.h"
Adding module source:"Headers/kab/err.h" >> "kab/.err.h"
Got entry for:"err.h~"
Ignoring file "err.h~"
Got entry for:"cipher.h~"
Ignoring file "cipher.h~"
Got entry for:"."
Got entry for:"kem.h"
Adding file "kem.h"
Adding module source:"Headers/kab/kem.h" >> "kab/.kem.h"
Got entry for:"hash.h~"
Ignoring file "hash.h~"
Got entry for:"prng.h"
Adding file "prng.h"
Adding module source:"Headers/kab/prng.h" >> "kab/.prng.h"
Got entry for:"keys.h"
Adding file "keys.h"
Adding module source:"Headers/kab/keys.h" >> "kab/.keys.h"
Got entry for:"radix64.h"
Adding file "radix64.h"
Adding module source:"Headers/kab/radix64.h" >> "kab/.radix64.h"
Got entry for:"cipher.h"
Adding file "cipher.h"
Adding module source:"Headers/kab/cipher.h" >> "kab/.cipher.h"
Got entry for:"hash.h"
Adding file "hash.h"
Adding module source:"Headers/kab/hash.h" >> "kab/.hash.h"
Got entry for:"curves.h"
Adding file "curves.h"
Adding module source:"Headers/kab/curves.h" >> "kab/.curves.h"
Got entry for:"base64.h"
Adding file "base64.h"
Adding module source:"Headers/kab/base64.h" >> "kab/.base64.h"
Got entry for:"kep"
Entering directory "kep/"
Using path:"Headers/kep/"
Got entry for:".."
Got entry for:"kep_dh.h"
Adding file "kep_dh.h"
Adding module source:"Headers/kep/kep_dh.h" >> "kep/.kep_dh.h"
Got entry for:"kep.h~"
Ignoring file "kep.h~"
Got entry for:"."
Got entry for:"kep_dhpass.h"
Adding file "kep_dhpass.h"
Adding module source:"Headers/kep/kep_dhpass.h" >> "kep/.kep_dhpass.h"
Got entry for:"kep_sts.h"
Adding file "kep_sts.h"
Adding module source:"Headers/kep/kep_sts.h" >> "kep/.kep_sts.h"
Got entry for:"kep.h"
Adding file "kep.h"
Adding module source:"Headers/kep/kep.h" >> "kep/.kep.h"
Got entry for:"."
Got entry for:"ktb.h"
Adding file "ktb.h"
Adding module source:"Headers/ktb.h" >> ".ktb.h"
STEP 1/x Adding modules
[. Adding modules
Using file "Headers/kab/sign.h" for module "sign"
. Adding modules
Using file "Headers/kab/kdf.h" for module "kdf"
. Adding modules
Using file "Headers/kab/err.h" for module "err"
. Adding modules
Using file "Headers/kab/kem.h" for module "kem"
. Adding modules
Using file "Headers/kab/prng.h" for module "prng"
. Adding modules
Using file "Headers/kab/keys.h" for module "keys"
. Adding modules
Using file "Headers/kab/radix64.h" for module "radix64"
. Adding modules
Using file "Headers/kab/cipher.h" for module "cipher"
. Adding modules
Using file "Headers/kab/hash.h" for module "hash"
. Adding modules
Using file "Headers/kab/curves.h" for module "curves"
. Adding modules
Using file "Headers/kab/base64.h" for module "base64"
. Adding modules
Using file "Headers/kep/kep_dh.h" for module "kep_dh"
. Adding modules
Using file "Headers/kep/kep_dhpass.h" for module "kep_dhpass"
. Adding modules
Using file "Headers/kep/kep_sts.h" for module "kep_sts"
. Adding modules
Using file "Headers/kep/kep.h" for module "kep"
. Adding modules
Using file "Headers/ktb.h" for module "ktb"
]
STEP 1/x Adding modules
STEP 2/x Parsing C headers
[. Parsing "sign"
Parsing module "sign"
Creating parser for "Headers/kab/sign.h"
Parsing "Headers/kab/sign.h"...
Setting struct name:"struct ktb_sign_ctx"
Typedef struct is an indirection
Setting struct typedef name:"ktb_sign_ctx_t"
Setting function name:"ktb_sign_init"
Adding parameter:[ctx:ktb_sign_ctx_t *]
Adding parameter:[algo:ktb_hash_algo_t]
Setting function name:"ktb_sign_clear"
Adding parameter:[ctx:ktb_sign_ctx_t]
Setting function name:"ktb_sign_reset"
Adding parameter:[ctx:ktb_sign_ctx_t]
Setting function name:"ktb_sign_process"
Adding parameter:[ctx:ktb_sign_ctx_t]
Adding parameter:[data:const void *]
Adding parameter:[data_size:size_t]
Setting function name:"ktb_sign_finalise"
Adding parameter:[ctx:ktb_sign_ctx_t]
Setting function name:"ktb_sign_set_public_key"
Adding parameter:[ctx:ktb_sign_ctx_t]
Adding parameter:[public_key:const_ktb_public_key_t]
Setting function name:"ktb_sign_verify"
Adding parameter:[ctx:ktb_sign_ctx_t]
Adding parameter:[signature:const void *]
Adding parameter:[signature_size:size_t]
Adding parameter:[is_valid:bool *]
Setting function name:"ktb_sign_verify_block"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[public_key:const_ktb_public_key_t]
Adding parameter:[data:const void *]
Adding parameter:[data_size:size_t]
Adding parameter:[signature:const void *]
Adding parameter:[signature_size:size_t]
Adding parameter:[is_valid:bool *]
Setting function name:"ktb_sign_set_private_key"
Adding parameter:[ctx:ktb_sign_ctx_t]
Adding parameter:[private_key:const_ktb_private_key_t]
Adding parameter:[prng:ktb_prng_t]
Setting function name:"ktb_sign_get_sign_size"
Adding parameter:[ctx:ktb_sign_ctx_t]
Setting function name:"ktb_sign_get_sign"
Adding parameter:[ctx:ktb_sign_ctx_t]
Adding parameter:[size:size_t *]
Setting function name:"ktb_sign_get_sign_size_from_key"
Adding parameter:[private_key:const_ktb_private_key_t]
Setting function name:"ktb_sign_sign_block"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[private_key:const_ktb_private_key_t]
Adding parameter:[data:const void *]
Adding parameter:[data_size:size_t]
Adding parameter:[signature:void *]
Adding parameter:[signature_size:size_t]
Functions:
Function(RET=ktb_errno,NAME=ktb_sign_init, ktb_sign_ctx_t *ctx, ktb_hash_algo_t algo); /** Create a signature context.
     *
     * After the context is created, you must call either
     * ktb_sign_set_public_key() or ktb_sign_set_private_key() to prepare the
     * context for verification/signature respectively.
     *
     * @param[out] ctx The context to initialize
     * @param[in] algo The hash algorithm to use for this signature. The hash must
     * be the same in both signature and verification.
     *
     * @retval KTB_ERR_NO_ERROR no error occurred
     * @retval KTB_ERR_INVALID_PARAMS @a ctx is NULL
     * @retval KTB_ERR_OUT_OF_MEM An error occured while allocating memory
     *
     * @note When an error occured, @a *ctx (if valid) is set to NULL.
     */
Function(RET=void,NAME=ktb_sign_clear, ktb_sign_ctx_t ctx); /** Cleanup a signature context
     *
     * @param[in] ctx The context to clear. If @a ctx == NULL, nothing happen.
     *
     * @note After ktb_sign_clear() have been called on a context, it can't be
     * used again.
     */
Function(RET=ktb_errno,NAME=ktb_sign_reset, ktb_sign_ctx_t ctx); /** Reset a signature context.
     *
     * Remove all input and computed signature from the context, but retain the
     * context key. After this call, the context can be reused to sign or verify
     * another message.
     *
     * @param[in] ctx The signature context
     *
     * @retval KTB_ERR_NO_ERROR No error occurred; the context is ready to be used
     *                          again
     * @retval KTB_ERR_INVALID_PARAMS @a ctx is NULL
     *
     * @return This function can also return an error code from
     * ktb_sign_set_private_key() or ktb_sign_set_public_key()
     *
     * @note If an error occured here, the context can't be used to perform any
     * operation before it is initialised again with either
     * ktb_sign_set_public_key() or ktb_sign_set_private_key().
     */
Function(RET=ktb_errno,NAME=ktb_sign_process, ktb_sign_ctx_t ctx, const void *data, size_t data_size); /** Append data to the signature context.
     *
     * In both sign and verify mode, you must use this function to feed the
     * message to the signature context.
     * This function can be called repeatedly to process a big source of data,
     * or a stream.
     *
     * @param[in] ctx The signature context
     * @param[in] data A pointer to the data to sign
     * @param[in] data_size The size of the buffer pointed by data
     *
     * @retval KTB_ERR_NO_ERROR No error occured
     * @retval KTB_ERR_INVALID_PARAMS One of the parameters is NULL or the context is
     *                                not setup for either signing or verifying (used
     *                                without a previous call to
     *                                ktb_sign_set_public_key() or
     *                                ktb_sign_set_private_key()).
     * @retval KTB_ERR_PROCESS_AFTER_FINISH ktb_sign_finalise() was already called on
     *                                      this context.
     *
     * @note If an error occur in this function, the context is cleared, meaning
     * you'll need to set it up before using it again (using
     * ktb_sign_set_public_key() or ktb_sign_set_private_key()).
     */
Function(RET=ktb_errno,NAME=ktb_sign_finalise, ktb_sign_ctx_t ctx); /** Finalise the data input of a signature context.
     *
     * When the whole message to sign/to verify was given to the context using
     * ktb_sign_process(), you must call this function to close the input.
     * In the case of a signing context, this will also trigger the computation
     * of the signature. If it is a signature verification context, you can then
     * call ktb_sign_verify() to check a signature against the message.
     *
     * @param[in] ctx The signature context
     *
     * @retval KTB_ERR_NO_ERROR No error occured
     * @retval KTB_ERR_INVALID_PARAMS @a ctx is NULL
     * @retval KTB_ERR_PROCESS_AFTER_FINISH This function was already called on this
     *                                      context
     * @retval KTB_ERR_OUT_OF_MEM Not enough memory available to perform this
     *                            operation
     *
     * @return This function can also return an error code from
     * ktb_prng_fill_buffer()
     *
     * @note If an error occur, using the context without setting it up again is
     * undefined.
     */
Function(RET=ktb_errno,NAME=ktb_sign_set_public_key, ktb_sign_ctx_t ctx, const_ktb_public_key_t public_key); /** Set the public key, and prepare the context for signature verification.
     *
     * When this function is called, the given context is setup to verify
     * signature. If the context was previously set to another key, or to sign
     * data, it is reset.
     *
     * @param[in] ctx The context to setup
     * @param[in] public_key The public key used to check signatures
     *
     * @retval KTB_ERR_NO_ERROR No error occured
     * @retval KTB_ERR_INVALID_PARAMS A mandatory parameter was omitted
     *
     * @return This function can also return an error code from ktb_hash_init()
     *
     * @note If an error occured in this function, the context is left uninitialized.
     *
     * @note For now, the key is not copied, so it must not be destroyed while
     * the signature context use it.
     */
Function(RET=ktb_errno,NAME=ktb_sign_verify, ktb_sign_ctx_t ctx, const void *signature, size_t signature_size, bool *is_valid); /** Check whether a signature corresponds to the given signed data.
     *
     * @param[in] ctx The signature context
     * @param[in] signature The signature to verify
     * @param[in] signature_size The size of signature
     * @param[out] is_valid Set to true if the signature is valid and no error
     *                      occurred in the computation, false otherwise.
     *
     * @retval KTB_ERR_NO_ERROR No error occurred during computation.
     * @retval KTB_ERR_SIGN_CORRUPT The data at \a signature isn't a signature
     * @retval KTB_ERR_OUT_OF_MEM Not enough memory to perform the verification
     * @retval KTB_ERR_INVALID_PARAMS One of the parameters was NULL, or the context
     *                                is a signing context
     * @retval KTB_ERR_BUFFER_SIZE_MISMATCH The given signature size is too small
     *
     * @note The context is left unaffected if an error occur here.
     */
Function(RET=ktb_errno,NAME=ktb_sign_verify_block, ktb_hash_algo_t algo, const_ktb_public_key_t public_key, const void *data, size_t data_size, const void *signature, size_t signature_size, bool *is_valid); /** All-in-one function used to verify a signature
     *
     * This function can be used when the signed data is relatively small, and
     * can be held in a single buffer.
     *
     * @param[in] algo The hash algorithm used before signing.
     * @param[in] public_key The public key used to verify the signature
     * @param[in] data The buffer containing the data to be signed
     * @param[in] data_size The size of @a data
     * @param[in] signature The signature to verify
     * @param[in] signature_size The size of the @a signature buffer
     * @param[out] is_valid A boolean variable used to determine if the signature
     * is valid.
     *
     * @return This function can return any error code from the individual
     * functions used in the verification process.
     */
Function(RET=ktb_errno,NAME=ktb_sign_set_private_key, ktb_sign_ctx_t ctx, const_ktb_private_key_t private_key, ktb_prng_t prng); /** Set the private key, and prepare the context to sign data.
     *
     * When this function is called, the given context is setup to sign data. If
     * the context was previously set to another key, or to verify signatures,
     * it is reset.
     *
     * @param[in] ctx The context to setup
     * @param[in] private_key The private key used to check signatures
     * @param[in] prng The PRNG used for signature
     *
     * @retval KTB_ERR_NO_ERROR No error occured
     * @retval KTB_ERR_INVALID_PARAMS A mandatory parameter was omitted
     * @retval KTB_ERR_OUT_OF_MEM An error occured while allocating memory
     *
     * @return This function can also return an error code from ktb_hash_init()
     *
     * @note If an error occured in this function, the context is left uninitialized.
     *
     * @note For now, the key is not copied, so it must not be destroyed while
     * the signature context use it.
     */
Function(RET=size_t,NAME=ktb_sign_get_sign_size, ktb_sign_ctx_t ctx); /** Return the size of a signature memory block.
     *
     * This function allow the caller to get the size of the signature before
     * calling ktb_sign_get_sign().
     *
     * @param[in] ctx The signature context
     *
     * @return The size needed to hold a signature from this context. If the context
     * is invalid, 0 is returned.
     */
Function(RET=const void *,NAME=ktb_sign_get_sign, ktb_sign_ctx_t ctx, size_t *size); /** Retrieve the signature computed for a given context.
     *
     * You can call this function on a signing context after ktb_sign_finalise()
     * to retrieve the computed signature.
     *
     * @param[in] ctx The signature context
     * @param[out] size The size of the returned buffer. This can be NULL if the size
     *                  is already known.
     *
     * @return A pointer to the signature block, whose size can be known by calling
     * ktb_sign_get_sign_size(), or NULL if the context is not a signing
     * context, or if the signature is not ready (before a call to
     * ktb_sign_finalise().
     * The pointer returned is valid until the context is reset or destroyed.
     *
     * @note The returned pointer must NOT be freed by the caller, as it is stored
     * in the signature context.
     */
Function(RET=size_t,NAME=ktb_sign_get_sign_size_from_key, const_ktb_private_key_t private_key); /** Return the size of a signature memory block.
     *
     * This function can be used without a signature context, in case of
     * complicated memory allocation issue that need the signature size to be
     * known even before initialising a signature context.
     *
     * @param[in] private_key The private key that will be used to sign.
     *
     * @return The size needed to hold a signature from this context. If the key is
     * invalid, 0 is returned.
     */
Function(RET=ktb_errno,NAME=ktb_sign_sign_block, ktb_hash_algo_t algo, ktb_prng_t prng, const_ktb_private_key_t private_key, const void *data, size_t data_size, void *signature, size_t signature_size); /** All-in-one function used to sign a block of data.
     *
     * This function can be used when the data to sign is relatively small, and
     * can be held in a single buffer.
     *
     * @param[in] algo The hash algorithm used before signing.
     * @param[in] prng The PRNG to use when signing
     * @param[in] private_key The private key used to compute the signature
     * @param[in] data The buffer containing the data to be signed
     * @param[in] data_size The size of @a data
     * @param[out] signature A buffer large enough to hold the signature
     * @param[out] signature_size The size of the @a signature buffer
     *
     * @return This function can return any error code from the individual
     * functions used in the signature process.
     *
     * @note data and signature can overlap; in this case data will be replaced by
     * signature (only if there is enough space, otherwise an error is returned)
     */
Enums:
Structs:
[struct ktb_sign_ctx>ktb_sign_ctx_t]
Callbacks:
Consts:

. Parsing "kdf"
Parsing module "kdf"
Creating parser for "Headers/kab/kdf.h"
Parsing "Headers/kab/kdf.h"...
Setting function name:"ktb_kdf"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[seed:const void *]
Adding parameter:[seed_size:size_t]
Adding parameter:[derived_key:void *]
Adding parameter:[derived_key_size:size_t]
Setting function name:"ktb_pbkdf"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[passwd:const void *]
Adding parameter:[passwd_size:size_t]
Adding parameter:[salt:const void *]
Adding parameter:[salt_size:size_t]
Adding parameter:[iteration_count:size_t]
Adding parameter:[derived_key:void *]
Adding parameter:[derived_key_size:size_t]
Setting function name:"ktb_kdf_max_size"
Adding parameter:[algo:ktb_hash_algo_t]
Functions:
Function(RET=ktb_errno,NAME=ktb_kdf, ktb_hash_algo_t algo, const void *seed, size_t seed_size, void *derived_key, size_t derived_key_size); /** Key derivation function (aka mask generation function).
 *
 * @param[in] algo The hash algorithm to use.
 * @param[in] seed The seed from which to derive a new key.
 * @param[in] seed_size The length of @a seed.
 * @param[out] derived_key Point to memory where the derived key should be put.
 * @param[in] derived_key_size The length of the generated @a derived_key.
 *
 * This function implements the KDF2 key derivation function, details
 * of which can be found in ISO-18033-2
 * (http://www.shoup.net/iso/std6.pdf).  Given a block of memory as the
 * @a seed, the function will fill the memory block at @a derived_key
 * with a value based on hashing @a seed with a counter.  The length
 * @a derived_key_size determines the length of the generated derived key.
 *
 * This function should only be used on "high-entropy"
 * (i.e. essentially random) shared secrets.  For shared secrets
 * coming from user supplied passwords (for example), use ktb_pbkdf()
 * instead.
 *
 * @see The site http://www.di-mgt.com.au/cryptoKDFs.html has an excellent
 * overview of the various key derivation functions available.
 */
Function(RET=ktb_errno,NAME=ktb_pbkdf, ktb_hash_algo_t algo, const void *passwd, size_t passwd_size, const void *salt, size_t salt_size, size_t iteration_count, void *derived_key, size_t derived_key_size); /** Password-based key generation function.
 *
 * @param[in] algo The hash algorithm to use.  It must support HMAC mode.
 * @param[in] passwd The seed password from which to derive a new key.
 * @param[in] passwd_size The length of @a passwd.
 * @param[in] salt The salt to apply to the computation.
 * @param[in] salt_size The length of @a salt.
 * @param[in] iteration_count The number of iterations to perform.
 * @param[out] derived_key A block of memory where the derived key should be put.
 * @param[in] derived_key_size The length of the generated @a derived_key.
 *
 * This function implements the PBKDF2 pasword-based key derivation
 * function, details of which can be found in RSA's document "PKCS #5
 * v2.1" (http://www.rsa.com/rsalabs/node.asp?id=2127)
 * 
 * This function should be prefered over ktb_kdf() when the shared
 * secret is a user supplied password or other "low-entropy"
 * (non-random) source.
 *
 * @todo
 * Add advice on the choice of @a salt and @a iteration_count.  See
 * section 4 of PKCS #5 v2.1.
 */
Function(RET=size_t,NAME=ktb_kdf_max_size, ktb_hash_algo_t algo); /** Return the maximum derived key size for a specific hash algorithm.
 *
 * @param[in] algo The algorithm used in the KDF.
 *
 * @return The maximum size of the derived key. Calling ktb_kdf() or
 * ktb_pbkdf() and asking for a derived key longer than this value will
 * return a @ref KTB_ERR_DERIVED_KEY_TOO_LONG error.
 */
Enums:
Structs:
Callbacks:
Consts:

. Parsing "err"
Parsing module "err"
Creating parser for "Headers/kab/err.h"
Parsing "Headers/kab/err.h"...
Adding enum value: [KTB_ERR_NO_ERROR=0]
Adding enum value: [KTB_ERR_UNKNOWN=1]
Adding enum value: [KTB_ERR_ERRNO=2]
Adding enum value: [KTB_ERR_INVALID_OFFSET=3]
Adding enum value: [KTB_ERR_INVALID_WHENCE=4]
Adding enum value: [KTB_ERR_UNKNOWN_FREAD_ERROR=5]
Adding enum value: [KTB_ERR_UNKNOWN_FWRITE_ERROR=6]
Adding enum value: [KTB_ERR_OUT_OF_MEM=7]
Adding enum value: [KTB_ERR_MEM_WRITE_FAILURE=8]
Adding enum value: [KTB_ERR_INVALID_PARAMS=9]
Adding enum value: [KTB_ERR_PRNG_SEED_FAILURE=10]
Adding enum value: [KTB_ERR_UNSUPPORTED_OPERATION=11]
Adding enum value: [KTB_ERR_SET_KEY_NOT_SUPPORTED=12]
Adding enum value: [KTB_ERR_UNKNOWN_HASH_ALGO=13]
Adding enum value: [KTB_ERR_DEST_BUFFER_TOO_SMALL=14]
Adding enum value: [KTB_ERR_HMAC_NO_KEY_SUPPLIED=15]
Adding enum value: [KTB_ERR_INVALID_ITER_COUNT=16]
Adding enum value: [KTB_ERR_DERIVED_KEY_TOO_LONG=17]
Adding enum value: [KTB_ERR_INVALID_KEY_SIZE=18]
Adding enum value: [KTB_ERR_INVALID_GCM_STATE=19]
Adding enum value: [KTB_ERR_BUFFER_SIZE_MISMATCH=20]
Adding enum value: [KTB_ERR_UNKNOWN_CIPHER_ALGO=21]
Adding enum value: [KTB_ERR_UNKNOWN_CIPHER_MODE=22]
Adding enum value: [KTB_ERR_NON_AUTHENTICATING_MODE=23]
Adding enum value: [KTB_ERR_INVALID_IV_LEN=24]
Adding enum value: [KTB_ERR_NO_KEY_SPECIFIED=25]
Adding enum value: [KTB_ERR_NO_IV_SPECIFIED=26]
Adding enum value: [KTB_ERR_PROCESS_AFTER_FINISH=27]
Adding enum value: [KTB_ERR_UNKNOWN_CURVE_ID=28]
Adding enum value: [KTB_ERR_INTERNAL_DB_ERROR=29]
Adding enum value: [KTB_ERR_INCOMPATIBLE_POINT_REPR=30]
Adding enum value: [KTB_ERR_POINTS_ON_DIFFERENT_CURVES=31]
Adding enum value: [KTB_ERR_INVALID_POINT=32]
Adding enum value: [KTB_ERR_INVALID_SIGNATURE=33]
Adding enum value: [KTB_ERR_UNKNOWN_KEP_ALGO=34]
Adding enum value: [KTB_ERR_HANDSHAKE=35]
Adding enum value: [KTB_ERR_KEP_TOO_MANY_PEERS=36]
Adding enum value: [KTB_ERR_KEP_STARVED=37]
Adding enum value: [KTB_ERR_KEP_NOT_STARVED=38]
Adding enum value: [KTB_ERR_KEP_COMPLETED=39]
Adding enum value: [KTB_ERR_KEP_INCOMPLETE=40]
Adding enum value: [KTB_ERR_KEM_ERROR=41]
Adding enum value: [KTB_ERR_SIGN_CORRUPT=42]
Adding enum value: [KTB_ERR_SIGN_NOT_READY=43]
Adding enum value: [KTB_ERR_DATA_INVALID=44]
Adding enum value: [KTB_ERRNO_MAX=45]
Setting enum typedef:"ktb_errno"
Setting function name:"ktb_strerror"
Adding parameter:[err:ktb_errno]
Adding parameter:[buf:char *]
Adding parameter:[buf_size:size_t]
Functions:
Function(RET=int,NAME=ktb_strerror, ktb_errno err, char *buf, size_t buf_size); /** The exchange is not yet complete. */
Enums:
[<unnamed>={KTB_ERR_NO_ERROR=0}{KTB_ERR_UNKNOWN=1}{KTB_ERR_ERRNO=2}{KTB_ERR_INVALID_OFFSET=3}{KTB_ERR_INVALID_WHENCE=4}{KTB_ERR_UNKNOWN_FREAD_ERROR=5}{KTB_ERR_UNKNOWN_FWRITE_ERROR=6}{KTB_ERR_OUT_OF_MEM=7}{KTB_ERR_MEM_WRITE_FAILURE=8}{KTB_ERR_INVALID_PARAMS=9}{KTB_ERR_PRNG_SEED_FAILURE=10}{KTB_ERR_UNSUPPORTED_OPERATION=11}{KTB_ERR_SET_KEY_NOT_SUPPORTED=12}{KTB_ERR_UNKNOWN_HASH_ALGO=13}{KTB_ERR_DEST_BUFFER_TOO_SMALL=14}{KTB_ERR_HMAC_NO_KEY_SUPPLIED=15}{KTB_ERR_INVALID_ITER_COUNT=16}{KTB_ERR_DERIVED_KEY_TOO_LONG=17}{KTB_ERR_INVALID_KEY_SIZE=18}{KTB_ERR_INVALID_GCM_STATE=19}{KTB_ERR_BUFFER_SIZE_MISMATCH=20}{KTB_ERR_UNKNOWN_CIPHER_ALGO=21}{KTB_ERR_UNKNOWN_CIPHER_MODE=22}{KTB_ERR_NON_AUTHENTICATING_MODE=23}{KTB_ERR_INVALID_IV_LEN=24}{KTB_ERR_NO_KEY_SPECIFIED=25}{KTB_ERR_NO_IV_SPECIFIED=26}{KTB_ERR_PROCESS_AFTER_FINISH=27}{KTB_ERR_UNKNOWN_CURVE_ID=28}{KTB_ERR_INTERNAL_DB_ERROR=29}{KTB_ERR_INCOMPATIBLE_POINT_REPR=30}{KTB_ERR_POINTS_ON_DIFFERENT_CURVES=31}{KTB_ERR_INVALID_POINT=32}{KTB_ERR_INVALID_SIGNATURE=33}{KTB_ERR_UNKNOWN_KEP_ALGO=34}{KTB_ERR_HANDSHAKE=35}{KTB_ERR_KEP_TOO_MANY_PEERS=36}{KTB_ERR_KEP_STARVED=37}{KTB_ERR_KEP_NOT_STARVED=38}{KTB_ERR_KEP_COMPLETED=39}{KTB_ERR_KEP_INCOMPLETE=40}{KTB_ERR_KEM_ERROR=41}{KTB_ERR_SIGN_CORRUPT=42}{KTB_ERR_SIGN_NOT_READY=43}{KTB_ERR_DATA_INVALID=44}{KTB_ERRNO_MAX=45}>ktb_errno]
Structs:
Callbacks:
Consts:

. Parsing "kem"
Parsing module "kem"
Creating parser for "Headers/kab/kem.h"
Parsing "Headers/kab/kem.h"...
Setting function name:"ktb_kem_psec_encrypt_size"
Adding parameter:[peer_public_key:const_ktb_public_key_t]
Setting function name:"ktb_kem_psec_encrypt"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[peer_public_key:const_ktb_public_key_t]
Adding parameter:[secret_key:void *]
Adding parameter:[secret_key_size:size_t]
Adding parameter:[ciphertext:void *]
Adding parameter:[ciphertext_size:size_t]
Setting function name:"ktb_kem_psec_decrypt"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[self_private_key:const_ktb_private_key_t]
Adding parameter:[input_ciphertext:const void *]
Adding parameter:[input_ciphertext_size:size_t]
Adding parameter:[secret_key:void *]
Adding parameter:[secret_key_size:size_t]
Functions:
Function(RET=size_t,NAME=ktb_kem_psec_encrypt_size, const_ktb_public_key_t peer_public_key); /** Return the size needed to hold an encapsulated key.
 *
 * @param[in] peer_public_key The public key used to encapsulate the secret
 * key.
 *
 * @return The size of the buffer needed by ktb_kem_psec_encrypt_size(),
 * or 0 if the key is invalid.
 *
 * @note You must use this function to find out the size of the buffer that must
 * be passed to ktb_kem_psec_encrypt().
 */
Function(RET=ktb_errno,NAME=ktb_kem_psec_encrypt, ktb_hash_algo_t algo, ktb_prng_t prng, const_ktb_public_key_t peer_public_key, void *secret_key, size_t secret_key_size, void *ciphertext, size_t ciphertext_size); /** Generate and encrypt a shared secret key.
 *
 * @param[in] algo The hash algorithm to use internally
 * @param[in] prng The PRNG to use to generate the secret key
 * @param[in] peer_public_key The public key of the other peer.
 * @param[out] secret_key The generated secret key. This space must have already
 * been allocated, and must be @a secret_key_size bytes long.
 * @param[in] secret_key_size The length of the secret key to generate.
 * This length is limited by the capability of ktb_kdf() and the kind of
 * curve used.
 * @param[out] ciphertext The encapsulated secret key, to be sent to the other
 * peer. This buffer must have been previously allocated by the application to at
 * least ktb_kem_psec_encrypt_size() bytes.
 * @param[in] ciphertext_size The size of the buffer allocated for @a ciphertext.
 *
 * @retval KTB_ERR_NO_ERROR No error occurred.
 * @retval KTB_ERR_INVALID_PARAMS One of the parameters given was NULL
 * @retval KTB_ERR_DERIVED_KEY_TOO_LONG @a secret_key_size is too big
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL The buffer allocated for @a ciphertext
 * is too small
 *
 * @return This function can also return an error code from ktb_kdf()
 */
Function(RET=ktb_errno,NAME=ktb_kem_psec_decrypt, ktb_hash_algo_t algo, const_ktb_private_key_t self_private_key, const void *input_ciphertext, size_t input_ciphertext_size, void *secret_key, size_t secret_key_size); /** Decrypt a key that was encapsulated with ktb_kem_psec_encrypt().
 *
 * @param[in] algo The hash algorithm used to derivate the key
 * @param[in] self_private_key The private key
 * @param[in] input_ciphertext The buffer received (this is the value put in 
 * @a ciphertext by ktb_kem_psec_encrypt()).
 * @param[in] input_ciphertext_size The size of input_ciphertext
 * @param[out] secret_key The place to put the decrypted shared secret key.
 * @param[in] secret_key_size The length of the key
 *
 * @retval KTB_ERR_NO_ERROR The key was successfuly retrieved
 * @retval KTB_ERR_BUFFER_SIZE_MISMATCH @a input_ciphertext is not large enough
 * to get data from it
 * @retval KTB_ERR_DERIVED_KEY_TOO_LONG @a secret_key_size is too big. Note that
 * this is triggered by the same limitation that is in ktb_kem_psec_encrypt()
 * @retval KTB_ERR_KEM_ERROR The retrieved key was invalid
 *
 * @return This function can also return an error code from ktb_kdf()
 *
 * @note Parameters must have the same size as described in ktb_kem_psec_encrypt().
 */
Enums:
Structs:
Callbacks:
Consts:

. Parsing "prng"
Parsing module "prng"
Creating parser for "Headers/kab/prng.h"
Parsing "Headers/kab/prng.h"...
Setting struct name:"struct ktb_prng"
Typedef struct is an indirection
Setting struct typedef name:"ktb_prng_t"
Setting function name:"ktb_prng_clear"
Adding parameter:[prng:ktb_prng_t]
Setting function name:"ktb_prng_reseed_with"
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[buffer:void *]
Adding parameter:[buffer_size:size_t]
Setting function name:"ktb_prng_reseed"
Adding parameter:[prng:ktb_prng_t]
Setting function name:"ktb_prng_fill_buffer"
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[buffer:void *]
Adding parameter:[buffer_size:size_t]
Functions:
Function(RET=void,NAME=ktb_prng_clear, ktb_prng_t prng); /** Clear the memory used by the pseudo-random number generator.
 *
 * @param[in] prng The PRNG to deallocate. It must have been initialized by a
 * call to ktb_prng_init_custom() before.
 */
Function(RET=ktb_errno,NAME=ktb_prng_reseed_with, ktb_prng_t prng, void *buffer, size_t buffer_size); /** Reseed the PRNG with user specified values.
 *
 * This function add a new seed to the PRNG. It does not replace the current
 * seed.
 *
 * @param[in] prng The PRNG to reseed. Can be NULL to use the internal PRNG.
 *
 * @param[in] buffer The seed to add to the PRNG
 *
 * @param[in] buffer_size The size of @a buffer
 *
 * @return This function can return KTB_ERR_NO_ERROR on success,
 * or any other value to indicate an error.
 *
 * @note If this function is called with a NULL value for @a buffer, 
 * it have the same effect as calling ktb_prng_reseed().
 */
Function(RET=ktb_errno,NAME=ktb_prng_reseed, ktb_prng_t prng); /** Reseed the PRNG with an internal entropy source.
 *
 * This function add a new seed to the PRNG. This new seed is taken from an
 * internal source.
 *
 * For the KTB PRNG, this source is:
 *  - on Posix systems: /dev/random or /dev/urandom
 *  - on Windows systems: The CryptoAPI random generator
 *
 * @param[in] prng The PRNG to reseed. Can be NULL to use the internal PRNG.
 *
 * @return This function can return KTB_ERR_NO_ERROR on success,
 * or any other value to indicate an error.
 *
 * @note Some entropy source might block the application if not enough 
 * entropy is available when the function is called.
 */
Function(RET=ktb_errno,NAME=ktb_prng_fill_buffer, ktb_prng_t prng, void *buffer, size_t buffer_size); /** Fill a buffer with random values.
 *
 * @param[in] prng The PRNG object. Can be NULL to use the internal PRNG.
 *
 * @param[out] buffer The buffer to fill with random data. 
 * It must already have been allocated.
 *
 * @param[in] buffer_size The size of @a buffer
 *
 * @return KTB_ERR_NO_ERROR on success, or an error value.
 */
Enums:
Structs:
[struct ktb_prng>ktb_prng_t]
Callbacks:
Consts:

. Parsing "keys"
Parsing module "keys"
Creating parser for "Headers/kab/keys.h"
Parsing "Headers/kab/keys.h"...
Setting struct name:"struct ktb_public_key"
Typedef struct is an indirection
Setting struct typedef name:"ktb_public_key_t"
Setting struct name:"const struct ktb_public_key"
Typedef struct is an indirection
Setting struct typedef name:"const_ktb_public_key_t"
Setting struct name:"struct ktb_private_key"
Typedef struct is an indirection
Setting struct typedef name:"ktb_private_key_t"
Setting struct name:"const struct ktb_private_key"
Typedef struct is an indirection
Setting struct typedef name:"const_ktb_private_key_t"
Setting function name:"ktb_keys_public_key_clear"
Adding parameter:[key:ktb_public_key_t]
Setting function name:"ktb_keys_private_key_clear"
Adding parameter:[key:ktb_private_key_t]
Setting function name:"ktb_keys_public_key_export_size"
Adding parameter:[public_key:const_ktb_public_key_t]
Setting function name:"ktb_keys_public_key_export"
Adding parameter:[public_key:const_ktb_public_key_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Setting function name:"ktb_keys_public_key_import"
Adding parameter:[public_key_bytes:const void *]
Adding parameter:[public_key_bytes_size:size_t]
Adding parameter:[public_key:ktb_public_key_t *]
Setting function name:"ktb_keys_private_key_export_size"
Adding parameter:[key:const_ktb_private_key_t]
Setting function name:"ktb_keys_private_key_export"
Adding parameter:[key:const_ktb_private_key_t]
Adding parameter:[buffer:void *]
Adding parameter:[buffer_size:size_t]
Setting function name:"ktb_keys_private_key_import"
Adding parameter:[private_key_bytes:const void *]
Adding parameter:[private_key_bytes_size:size_t]
Adding parameter:[private_key:ktb_private_key_t *]
Setting function name:"ktb_keys_generate_keypair"
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[curve_id:const char *]
Adding parameter:[public_key:ktb_public_key_t *]
Adding parameter:[private_key:ktb_private_key_t *]
Functions:
Function(RET=void,NAME=ktb_keys_public_key_clear, ktb_public_key_t key); /** Safely free the memory associated with the public key @a key.
 *
 * @param[in] key A pointer to the public key to cleanup. 
 * It is possible to pass a NULL pointer without raising an error.
 *
 * @note The @a key pointer should not be used after this call.
 */
Function(RET=void,NAME=ktb_keys_private_key_clear, ktb_private_key_t key); /** Safely free the memory associated with the private key @a key.
 *
 * @param[in] key A pointer to the public key to cleanup.
 * It is possible to pass a NULL pointer without raising an error.
 *
 * @note The @a key pointer should not be used after this call.
 */
Function(RET=size_t,NAME=ktb_keys_public_key_export_size, const_ktb_public_key_t public_key); /** Return the size needed to hold an exported public key.
 *
 * @param[in] public_key The public key to convert to a byte buffer
 *
 * @return The size of the needed buffer, in bytes, or 0 if @a public_key is
 * NULL.
 */
Function(RET=ktb_errno,NAME=ktb_keys_public_key_export, const_ktb_public_key_t public_key, void *result, size_t result_size); /** Export a public key to an opaque byte buffer.
 *
 * @param[in] public_key The public key to export
 * @param[out] result A buffer to hold the key bytes
 * @param [in] result_size The size of the @a result buffer. This buffer
 * should have already been allocated by the application, and must have a
 * size of at least the return value from ktb_keys_public_key_export_size().
 *
 * @retval KTB_ERR_NO_ERROR on success
 * @retval KTB_ERR_INVALID_PARAMS if a mandatory parameter is missing
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL if @a result_size is not large enough
 *
 * @note In case of error, @a result content is unspecified.
 */
Function(RET=ktb_errno,NAME=ktb_keys_public_key_import, const void *public_key_bytes, size_t public_key_bytes_size, ktb_public_key_t *public_key); /** Import back an opaque byte buffer as a public key.
 *
 * @param [in] public_key_bytes The source buffer
 * @param [in] public_key_bytes_size The size of the source buffer
 * @param [out] public_key The resulting public key
 *
 * @retval KTB_ERR_NO_ERROR no error occured
 * @retval KTB_ERR_INVALID_PARAMS one of the parameter is NULL
 * @retval KTB_ERR_OUT_OF_MEM an error occured while allocating memory
 * @retval KTB_ERR_DATA_INVALID @a public_key_bytes contain invalid data
 *
 * @note If an error occured, there is no public key created, and @a public_key
 * is set to NULL.
 */
Function(RET=size_t,NAME=ktb_keys_private_key_export_size, const_ktb_private_key_t key); /** Determine the size needed to hold a private key in a byte buffer.
 *
 * @param[in] key The private key to convert
 *
 * @return The size of the needed buffer, or 0 if @a key is invalid
 */
Function(RET=ktb_errno,NAME=ktb_keys_private_key_export, const_ktb_private_key_t key, void *buffer, size_t buffer_size); /** Export a private key to an opaque byte buffer.
 *
 * @param[in] key The key to convert
 * @param[out] buffer The buffer that will receive the key
 * @param[in] buffer_size The size of buffer.
 *
 * @retval KTB_ERR_NO_ERROR no error occured
 * @retval KTB_ERR_INVALID_PARAMS if @a key of @a buffer is NULL
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL @a buffer is too small to hold the
 * exported key
 *
 * @note When an error occur, @a buffer content is unspecified.
 */
Function(RET=ktb_errno,NAME=ktb_keys_private_key_import, const void *private_key_bytes, size_t private_key_bytes_size, ktb_private_key_t *private_key); /** Import back a byte buffer as a private key
 *
 * @param[in] private_key_bytes The bytes to convert back to a private key
 * @param[in] private_key_bytes_size The size of the private_key_bytes buffer
 * @param[out] private_key The resulting private key
 *
 * @retval KTB_ERR_NO_ERROR the private key was retrieved successfully
 * @retval KTB_ERR_INVALID_PARAMS if @a private_key or @a private_key_bytes
 *                                is NULL
 * @retval KTB_ERR_DATA_INVALID @a private_key_bytes contain invalid data
 * @retval KTB_ERR_OUT_OF_MEM an error occured while allocating memory
 *
 * @note If an error occured, there is no private key created.
 */
Function(RET=ktb_errno,NAME=ktb_keys_generate_keypair, ktb_prng_t prng, const char *curve_id, ktb_public_key_t *public_key, ktb_private_key_t *private_key); /**
 * Generate a pair of public/private keys.
 *
 * @todo
 * Add a paragraph describing the recommended key sizes for
 * different levels of security, in particular mentioning the
 * size one should pick assuming the use of a block cipher of
 * a particular "strength".
 *
 * @param[in] prng The PRNG to use to generate a random key
 * @param[in] curve_id The Arcana-ECDB identifier of the curve used to generate
 * this keypair.
 * @param[out] public_key The place to put the generated public key
 * @param[out] private_key The place to put the generated private key
 *
 * @retval KTB_ERR_NO_ERROR the keys were generated successfuly
 * @retval KTB_ERR_INVALID_PARAMS one of the parameter was NULL,
 * or @a keysize is invalid
 * @retval KTB_ERR_OUT_OF_MEM an error occured while allocating memory
 *
 * @return This function can also return an error value from
 * ktb_prng_fill_buffer()
 *
 * @note If an error happen, no keys are created, and @a public_key and @a
 * private_key are set to NULL.
 */
Enums:
Structs:
[struct ktb_public_key>ktb_public_key_t]
[const struct ktb_public_key>const_ktb_public_key_t]
[struct ktb_private_key>ktb_private_key_t]
[const struct ktb_private_key>const_ktb_private_key_t]
Callbacks:
Consts:

. Parsing "radix64"
Parsing module "radix64"
Creating parser for "Headers/kab/radix64.h"
Parsing "Headers/kab/radix64.h"...
Setting function name:"ktb_radix64_encode_size"
Adding parameter:[input_size:size_t]
Setting function name:"ktb_radix64_encode"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Setting function name:"ktb_radix64_decode_size"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Setting function name:"ktb_radix64_decode"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Setting function name:"ktb_radix64_verify"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Adding parameter:[verified:bool *]
Functions:
Function(RET=size_t,NAME=ktb_radix64_encode_size, size_t input_size); /** Return the size needed to encode a buffer in radix64
 *
 * @param[in] input_size
 * The input buffer size
 *
 * @return
 * The full size needed to hold the encoded result, without the terminating
 * NULL character.
 */
Function(RET=ktb_errno,NAME=ktb_radix64_encode, const void *input, size_t input_size, void *result, size_t result_size); /** Convert a byte sequence to a radix64 encoded string
 *
 * @param[in] input
 * The input buffer
 *
 * @param[in] input_size
 * The size of the @a input buffer
 *
 * @param[out] result
 * A place to put the encoded string
 *
 * @param[in] result_size
 * The size of the @a result buffer. The needed size can be retrieved with
 * ktb_radix64_encode_size()
 *
 * @retval KTB_ERR_NO_ERROR
 * success
 *
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL
 * The @a result buffer is too small to hold the encoded result
 *
 * @return
 * This function can return any error code from ktb_hash_block().
 *
 * @note
 * If an error occur, the content of @a result is undefined.
 *
 * @note
 * The function does not add the terminal NULL character; it is the
 * responsibility of the caller to do so if needed.
 */
Function(RET=size_t,NAME=ktb_radix64_decode_size, const void *input, size_t input_size); /** Return the size needed to decode a radix64 encoded string
 *
 * @param[in] input
 * The input buffer
 *
 * @param[in] input_size
 * The size of the @a input buffer
 *
 * @return
 * 0 if the input buffer is invalid, or the size needed to hold the decoded
 * content of @a input with ktb_radix64_decode
 */
Function(RET=ktb_errno,NAME=ktb_radix64_decode, const void *input, size_t input_size, void *result, size_t result_size); /** Convert a radix64 string into a byte sequence
 *
 * @param[in] input
 * The source radix64 encoded string
 *
 * @param[in] input_size
 * The size of @a input
 *
 * @param[out] result
 * A place to hold the decoded buffer
 *
 * @param[in] result_size
 * The size of the @a result buffer
 *
 * @return
 * This function can return the same error code as ktb_base64_decode
 */
Function(RET=ktb_errno,NAME=ktb_radix64_verify, const void *input, size_t input_size, bool *verified); /** Check the CRC24 of a radix64 string
 *
 * @param[in] input
 * The input buffer
 *
 * @param[in] input_size
 *
 * @param[out] verified
 * This boolean will be set to @c true if the CRC is valid, @c false
 * otherwise.
 *
 * @retval KTB_ERR_NO_ERROR
 * No error occured during the verification. This is not indicating that the
 * CRC is verified; see @a verified for that.
 *
 * @retval KTB_ERR_INVALID_PARAMS
 * @a verified is NULL or another parameter is invalid.
 *
 * @retval KTB_ERR_DATA_INVALID
 * The input data is not a valid radix64 input.
 *
 * @return
 * This function can also return error codes from ktb_radix64_decode(),
 * ktb_hash_block() or ktb_base64_encode()
 */
Enums:
Structs:
Callbacks:
Consts:

. Parsing "cipher"
Parsing module "cipher"
Creating parser for "Headers/kab/cipher.h"
Parsing "Headers/kab/cipher.h"...
Adding enum value: [KTB_CIPHER_ALGO_AES128=0]
Adding enum value: [KTB_CIPHER_ALGO_AES192=1]
Adding enum value: [KTB_CIPHER_ALGO_AES256=2]
Adding enum value: [KTB_CIPHER_ALGO_TWOFISH128=3]
Adding enum value: [KTB_CIPHER_ALGO_TWOFISH192=4]
Adding enum value: [KTB_CIPHER_ALGO_TWOFISH256=5]
Setting enum typedef:"ktb_cipher_algo_t"
Adding enum value: [KTB_CIPHER_MODE_CTR=0]
Adding enum value: [KTB_CIPHER_MODE_GCM=1]
Adding enum value: [KTB_CIPHER_MODE_CBC=2]
Setting enum typedef:"ktb_cipher_mode_t"
Setting struct name:"struct ktb_cipher_ctx"
Typedef struct is an indirection
Setting struct typedef name:"ktb_cipher_ctx_t"
Setting function name:"ktb_cipher_init"
Adding parameter:[ctx:ktb_cipher_ctx_t *]
Adding parameter:[algo:ktb_cipher_algo_t]
Adding parameter:[mode:ktb_cipher_mode_t]
Adding parameter:[encryption:bool]
Setting function name:"ktb_cipher_clear"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_reset"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_set_key"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[key:const void *]
Adding parameter:[key_size:size_t]
Setting function name:"ktb_cipher_set_iv"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[iv:const void *]
Adding parameter:[iv_size:size_t]
Setting function name:"ktb_cipher_set_auth_data"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[auth_data:const void *]
Adding parameter:[auth_data_size:size_t]
Setting function name:"ktb_cipher_get_prefix_size"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_prefix"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[prefix:void *]
Adding parameter:[prefix_size:size_t]
Setting function name:"ktb_cipher_set_prefix"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[prefix:void *]
Adding parameter:[prefix_size:size_t]
Setting function name:"ktb_cipher_get_suffix_size"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_suffix"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[suffix:void *]
Adding parameter:[suffix_size:size_t]
Setting function name:"ktb_cipher_encrypt_block"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[in:const void *]
Adding parameter:[in_size:size_t]
Adding parameter:[out:void *]
Adding parameter:[out_size:size_t]
Setting function name:"ktb_cipher_decrypt_block"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[in:const void *]
Adding parameter:[in_size:size_t]
Adding parameter:[out:void *]
Adding parameter:[out_size:size_t]
Setting function name:"ktb_cipher_finalise"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_mac"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Adding parameter:[size:size_t *]
Setting function name:"ktb_cipher_get_data_size"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_name_from_algo"
Adding parameter:[algo:ktb_cipher_algo_t]
Setting function name:"ktb_cipher_get_name_from_mode"
Adding parameter:[mode:ktb_cipher_mode_t]
Setting function name:"ktb_cipher_get_key_len"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_block_len"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_iv_len"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_mac_size"
Adding parameter:[ctx:ktb_cipher_ctx_t]
Setting function name:"ktb_cipher_get_iv_len_from_mode"
Adding parameter:[mode:ktb_cipher_mode_t]
Functions:
Function(RET=ktb_errno,NAME=ktb_cipher_init, ktb_cipher_ctx_t *ctx, ktb_cipher_algo_t algo, ktb_cipher_mode_t mode, bool encryption); /** Create a block cipher context.
     *
     * @param[out] ctx The context to initialize
     * @param[in] algo The cipher algorithm to use with this context
     * @param[in] mode The cipher mode to use with this context
     * @param[in] encryption Specify the direction of this cipher. Set to true
     * to create an ciphering context, or false to get a deciphering context.
     *
     * @retval KTB_ERR_UNKNOWN_CIPHER_ALGO An invalid cipher algorithm is
     * specified in @a algo
     * @retval KTB_ERR_UNKNOWN_CIPHER_MODE An invalid cipher mode is specified
     * in @a mode
     * @retval KTB_ERR_OUT_OF_MEM An error occured while allocating memory
     *
     * @return @ref KTB_ERR_NO_ERROR in case of success, or an error code when
     * something wrong happened.
     */
Function(RET=void,NAME=ktb_cipher_clear, ktb_cipher_ctx_t ctx); /** Release the memory associated with a block cipher context.
     *
     * @param[in] ctx The initialized context to clear
     *
     * @note This function must be called on every context initialized with
     * ktb_cipher_init(), even if an error occur during operations.
     */
Function(RET=void,NAME=ktb_cipher_reset, ktb_cipher_ctx_t ctx); /** Reset a cipher context.
     *
     * @param[in] ctx An initialized context
     *
     * A reset cipher context can be reused with the same settings (key, ...)
     * but with a new input.
     *
     * @warning This function is not implemented for every algorithm/mode
     *
     * @note A new IV must be provided after a reset.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_set_key, ktb_cipher_ctx_t ctx, const void *key, size_t key_size); /** Set the key for use with the cipher context.
     *
     * @param[in] ctx An initialized context
     * @param[in] key The secret key to use for (de)ciphering
     * @param[in] key_size The size of the data pointed by @a key
     *
     * @return @ref KTB_ERR_NO_ERROR in case of success, or an error code when
     * something wrong happened.
     *
     * @note The key must have a size compatible with the specified algorithm. The
     * needed key size can be retrieved by calling ktb_cipher_get_key_len().
     *
     * @attention A key must be set before the cipher context can be used
     * for encryption or decryption.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_set_iv, ktb_cipher_ctx_t ctx, const void *iv, size_t iv_size); /** Set the IV for this cipher context
     *
     * @param[in] ctx An initialized context
     * @param[in] iv The initialization vector to use
     * @param[in] iv_size The size of the data pointed by @a iv
     *
     * @return @ref KTB_ERR_NO_ERROR in case of success, or an error code when
     * something wrong happened.
     *
     * @note The IV must have a size compatible with the specified mode of
     * operation. This size can be retrieved by calling ktb_cipher_get_iv_len().
     *
     * @attention If the cipher mode need an IV, it must be set before the
     * context can be used.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_set_auth_data, ktb_cipher_ctx_t ctx, const void *auth_data, size_t auth_data_size); /** Puts @a ctx's mode into authentication mode if possible.
     *
     * @param[in] ctx An initialized context
     * @param[in] auth_data The extra authentication data to use
     * @param[in] auth_data_size The size of the data pointed by @a auth_data
     *
     * @retval KTB_ERR_NO_ERROR no error occured
     * @retval KTB_ERR_NON_AUTHENTICATING_MODE the specified mode of operation
     * can't provide authentication
     *
     * @return This function can also return other error codes.
     *
     * If Galois/Counter Mode (GCM) is being used, this function can be used to
     * set the additional authentication data (AAD).  If the AAD is set then
     * the integrity data will be generated; if it is not set then no
     * integrity data will be generated.
     *
     * If GCM is not being used, this function does nothing.
     */
Function(RET=size_t,NAME=ktb_cipher_get_prefix_size, ktb_cipher_ctx_t ctx); /** Return the size of the prefix to add to ciphered data.
     *
     * This function should be called before actual ciphering (before
     * ktb_cipher_encrypt_block) to inquiry the size of the prefix block.
     *
     * @param[in] ctx The initialized context that will be used to (de)cipher.
     *
     * @return The size of the prefix block. It can be 0; in this case, it is
     * not needed to call ktb_cipher_get_prefix() or ktb_cipher_set_prefix().
     * Otherwise, those calls are mandatory.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_get_prefix, ktb_cipher_ctx_t ctx, void *prefix, size_t prefix_size); /** Retrieve the prefix to add to ciphered data.
     *
     * This function should be called before the actual ciphering occur. The
     * prefix data it return must be prefixed to the ciphered data, and is part
     * of the ciphered data.
     *
     * @param[in] ctx The initialized context that will be used to cipher
     * @param[out] prefix A buffer to receive the prefix data
     * @param[in] prefix_size The size of the @a prefix buffer. It must be at
     * least large enough to hold the number of bytes returned by
     * ktb_cipher_get_prefix_size().
     *
     * @return An error code
     * @todo Document error code
     */
Function(RET=ktb_errno,NAME=ktb_cipher_set_prefix, ktb_cipher_ctx_t ctx, void *prefix, size_t prefix_size); /** Feed the prefix to the cipher.
     *
     * This function must be called before deciphering occur, with the prefix
     * part. The prefix real size can be determined by calling
     * ktb_cipher_get_prefix_size().
     *
     * @param[in] ctx The initialized context that will be used to decipher
     * @param[in] prefix The received prefix data
     * @param[in] prefix_size The received prefix size. It must be at least
     * ktb_cipher_get_prefix_size() bytes long, and only that much byte are
     * relevant (meaning you can pass larger buffer if needed).
     *
     * @return An error code
     * @todo Document error code
     */
Function(RET=size_t,NAME=ktb_cipher_get_suffix_size, ktb_cipher_ctx_t ctx); /** Return the size of the suffix to add to ciphered data.
     *
     * This function should be called after actual ciphering (after the last
     * ktb_cipher_encrypt_block()) to inquiry the size of the suffix block.
     *
     * @param[in] ctx The initialized context that was used to (de)cipher.
     *
     * @return The size of the suffix block. It can be 0; in this case, it is
     * not needed to call ktb_cipher_get_suffix(). Otherwise this call is
     * mandatory.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_get_suffix, ktb_cipher_ctx_t ctx, void *suffix, size_t suffix_size); /** Retrieve the suffix to add to ciphered data.
     *
     * This function should be called after the actual ciphering occured. The
     * suffix data it return must be suffixed to the ciphered data, and is part
     * of the ciphered data.
     *
     * @param[in] ctx The initialized context that was used to cipher
     * @param[out] suffix A buffer to receive the suffix data
     * @param[in] suffix_size The size of the @a suffix buffer. It must be at
     * least large enough to hold the number of bytes returned by
     * ktb_cipher_get_suffix_size().
     *
     * @return An error code
     * @todo Document error code
     */
Function(RET=ktb_errno,NAME=ktb_cipher_encrypt_block, ktb_cipher_ctx_t ctx, const void *in, size_t in_size, void *out, size_t out_size); /** Encrypt a block of bytes.
     *
     * @param[in] ctx An initialized context
     * @param[in] in A pointer to the buffer containing the input data
     * @param[in] in_size The size of the @a in buffer
     * @param[out] out A pointer to a buffer that will receive the ciphered data
     * @param[in] out_size The size of the @a out buffer
     *
     * @return @ref KTB_ERR_NO_ERROR when no error occur, or an error code
     *
     * Works in-place or with two buffers. Can be called multiple times
     * to process large bits of data in pieces, however EVERY PIECE must
     * be a multiple of the block size of the underlying cipher (almost
     * always 16 bytes).  Again: this function may be called multiple times
     * with input whose length is a multiple of the block size, and after
     * that exactly ONE call can be made where the input length is not
     * a multiple of the block size.
     *
     * @note The block size of the underlying cipher/mode can be retrieved by
     * calling ktb_cipher_get_block_len()
     *
     * @note Some mode of operation (namely CBC) need the output size to ALWAYS
     * be a multiple of the block size, greater or equal to the size of the
     * input.
     */
Function(RET=ktb_errno,NAME=ktb_cipher_decrypt_block, ktb_cipher_ctx_t ctx, const void *in, size_t in_size, void *out, size_t out_size); /** Decrypt a block of bytes.
     *
     * @param[in] ctx An initialized context
     * @param[in] in The input data (the ciphered content)
     * @param[in] in_size The size of the @a in buffer
     * @param[out] out A buffer that will receive the deciphered data
     * @param[in] out_size The size of the @a out buffer
     *
     * @return @ref KTB_ERR_NO_ERROR in case of success, or another error code
     *
     * See comment for ktb_cipher_encrypt_block().
     */
Function(RET=void,NAME=ktb_cipher_finalise, ktb_cipher_ctx_t ctx); /** Finalize the authenticity tag computation.
     *
     * @param[in] ctx An initialized context
     *
     * This function must be called once, at the end of the
     * ciphering/deciphering operation, before the authenticity tag
     * can be retrieved. It is not needed when not using authenticity.
     */
Function(RET=const void *,NAME=ktb_cipher_get_mac, ktb_cipher_ctx_t ctx, size_t *size); /** Retrieve the authentication tag generated by the Galois/Counter Mode.
     *
     * @param[in] ctx An initialized context
     * @param[out] size The size of the generated MAC
     *
     * @return The generated MAC, or NULL if an error occured (no AAD set, or @a
     * ctx is not ready)
     *
     * If Galois/Counter Mode (GCM) is being used and if additional
     * authentication data (AAD) was set (using ktb_cipher_set_auth_data()),
     * this function returns the authentication tag generated by GCM.  The
     * tag should be sent to the recipient along with the AAD and the
     * ciphertext (from ktb_cipher_encrypt_block()).  The
     * recipient can then verify the authenticity of the data by comparing it's
     * own computed MAC with the received value.
     */
Function(RET=size_t,NAME=ktb_cipher_get_data_size, ktb_cipher_ctx_t ctx); /** Return the size of the treated data.
     *
     * This function can be called at the end of operation (after the finalise
     * part, or if applicable after the ktb_cipher_set_suffix() call).
     *
     * When ciphering, this will return the number of ciphered bytes. When
     * deciphering, it will return the real number of deciphered bytes. It might
     * happen that deciphering return a buffer longer than the actual ciphered
     * data size; this function is then used to retrieve the original input size
     *
     * @param[in] ctx The context
     *
     * @return The real size of the processed data.
     */
Function(RET=const char *,NAME=ktb_cipher_get_name_from_algo, ktb_cipher_algo_t algo); /** Return the human readable name of a cipher algorithm.
     *
     * @param[in] algo The cipher algorithm identifier
     *
     * @return A null-terminated string containing the name of the algorithm.
     */
Function(RET=const char *,NAME=ktb_cipher_get_name_from_mode, ktb_cipher_mode_t mode); /** Return the human readable name of a cipher mode.
     *
     * @param[in] mode The cipher mode identifier
     *
     * @return A null-terminated string containing the name of the mode.
     */
Function(RET=size_t,NAME=ktb_cipher_get_key_len, ktb_cipher_ctx_t ctx); /** Return the length of the key needed by a context.
     *
     * @param[in] ctx An initialized context
     *
     * @return The length of the needed key, in bytes.
     */
Function(RET=size_t,NAME=ktb_cipher_get_block_len, ktb_cipher_ctx_t ctx); /** Return the length of the cipher block for a context
     *
     * @param[in] ctx An initialized context
     *
     * @return The size of a block
     *
     * See ktb_cipher_encrypt_block() for information on how to use the cipher
     * block size.
     */
Function(RET=size_t,NAME=ktb_cipher_get_iv_len, ktb_cipher_ctx_t ctx); /** Return the length of the IV for a context
     *
     * @param[in] ctx An initialized context
     *
     * @return The size of the IV. If it return a positive value, this mean that
     * the IV size is fixed. When returning 0, it mean that any IV size can be
     * used.
     */
Function(RET=size_t,NAME=ktb_cipher_get_mac_size, ktb_cipher_ctx_t ctx); /** Return the length of the MAC
     *
     * @param[in] ctx An initialized context
     *
     * @return The length of the MAC, if any.
     */
Function(RET=size_t,NAME=ktb_cipher_get_iv_len_from_mode, ktb_cipher_mode_t mode); /** Return the length of the IV for a given mode
     *
     * @param[in] mode A ciphering mode
     *
     * @return The size of the IV. If it return a positive value, this mean that
     * the IV size is fixed. When returning 0, it mean that any IV size can be
     * used.
     */
Enums:
[<unnamed>={KTB_CIPHER_ALGO_AES128=0}{KTB_CIPHER_ALGO_AES192=1}{KTB_CIPHER_ALGO_AES256=2}{KTB_CIPHER_ALGO_TWOFISH128=3}{KTB_CIPHER_ALGO_TWOFISH192=4}{KTB_CIPHER_ALGO_TWOFISH256=5}>ktb_cipher_algo_t]
[<unnamed>={KTB_CIPHER_MODE_CTR=0}{KTB_CIPHER_MODE_GCM=1}{KTB_CIPHER_MODE_CBC=2}>ktb_cipher_mode_t]
Structs:
[struct ktb_cipher_ctx>ktb_cipher_ctx_t]
Callbacks:
Consts:

. Parsing "hash"
Parsing module "hash"
Creating parser for "Headers/kab/hash.h"
Parsing "Headers/kab/hash.h"...
Setting enum name:"enum ktb_hash_algo"
Adding enum value: [KTB_HASH_ALGO_SHA1=0]
Adding enum value: [KTB_HASH_ALGO_SHA224=1]
Adding enum value: [KTB_HASH_ALGO_SHA256=2]
Adding enum value: [KTB_HASH_ALGO_SHA384=3]
Adding enum value: [KTB_HASH_ALGO_SHA512=4]
Adding enum value: [KTB_HASH_ALGO_CRC24=5]
Adding enum value: [KTB_HASH_ALGO_SKEIN256=6]
Adding enum value: [KTB_HASH_ALGO_SKEIN512=7]
Adding enum value: [KTB_HASH_ALGO_SKEIN1024=8]
Adding enum value: [KTB_HASH_ALGO_SHABAL192=9]
Adding enum value: [KTB_HASH_ALGO_SHABAL224=10]
Adding enum value: [KTB_HASH_ALGO_SHABAL256=11]
Adding enum value: [KTB_HASH_ALGO_SHABAL384=12]
Adding enum value: [KTB_HASH_ALGO_SHABAL512=13]
Setting enum typedef:"ktb_hash_algo_t"
Setting struct name:"struct ktb_hash_ctx"
Typedef struct is an indirection
Setting struct typedef name:"ktb_hash_ctx_t"
Setting function name:"ktb_hash_init"
Adding parameter:[ctx:ktb_hash_ctx_t]
Adding parameter:[algo:ktb_hash_algo_t]
Setting function name:"ktb_hash_init_hmac"
Adding parameter:[ctx:ktb_hash_ctx_t]
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[key:const void *]
Adding parameter:[key_size:size_t]
Setting function name:"ktb_hash_clear"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_reset"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_process"
Adding parameter:[ctx:ktb_hash_ctx_t]
Adding parameter:[buf:const void *]
Adding parameter:[buf_size:size_t]
Setting function name:"ktb_hash_finalise"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_retrieve"
Adding parameter:[ctx:ktb_hash_ctx_t]
Adding parameter:[size:size_t]
Setting function name:"ktb_hash_get_name"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_get_name_from_algo"
Adding parameter:[algo:ktb_hash_algo_t]
Setting function name:"ktb_hash_get_len"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_get_len_from_algo"
Adding parameter:[algo:ktb_hash_algo_t]
Setting function name:"ktb_hash_get_block_size"
Adding parameter:[ctx:ktb_hash_ctx_t]
Setting function name:"ktb_hash_block"
Adding parameter:[algo:ktb_hash_algo_t]
Adding parameter:[block:const void *]
Adding parameter:[block_size:size_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Functions:
Function(RET=ktb_errno,NAME=ktb_hash_init, ktb_hash_ctx_t ctx, ktb_hash_algo_t algo); /** Initialise a hash context.
 *
 * @param[out] ctx The context to initialise.
 * @param[in] algo The hash algorithm to use.
 *
 * @retval KTB_ERR_NO_ERROR No error occured
 * @retval KTB_ERR_UNKNOWN_HASH_ALGO The @a algo value is invalid
 * @retval KTB_ERR_OUT_OF_MEM An error occured when trying to allocate memory
 */
Function(RET=ktb_errno,NAME=ktb_hash_init_hmac, ktb_hash_ctx_t ctx, ktb_hash_algo_t algo, const void *key, size_t key_size); /** Initialise an HMAC context.
 *
 * @param[out] ctx The context to initialise.
 * @param[in] algo The hash algorithm to use.
 * @param[in] key The key for the MAC.
 * @param[in] key_size The length of @a key.
 *
 * @retval KTB_ERR_NO_ERROR No error occured
 * @retval KTB_ERR_UNKNOWN_HASH_ALGO The @a algo value is invalid
 * @retval KTB_ERR_OUT_OF_MEM An error occured when trying to allocate memory
 */
Function(RET=void,NAME=ktb_hash_clear, ktb_hash_ctx_t ctx); /** Clear all resources associated with a hash context.
 *
 * @param[in] ctx An initialized context
 */
Function(RET=void,NAME=ktb_hash_reset, ktb_hash_ctx_t ctx); /** Reset a hash context.
 *
 * @param[in] ctx The hash context to reset.
 *
 * After calling ktb_hash_reset(), @a ctx will be in the state it was
 * immediately after ktb_hash_init() or ktb_hash_init_hmac() was called.
 * Calling ktb_hash_reset() is faster than clearing and then reinitialising
 * @a ctx.
 */
Function(RET=void,NAME=ktb_hash_process, ktb_hash_ctx_t ctx, const void *buf, size_t buf_size); /** Process a block of data.
 *
 * Append the contents of @a buf to the stream of data being hashed.
 *
 * @param[in] ctx An initialized context
 * @param[in] buf Pointer to the block of memory to be hashed.
 * @param[in] buf_size The length of @a buf.
 */
Function(RET=void,NAME=ktb_hash_finalise, ktb_hash_ctx_t ctx); /** Finalise the hash computation.
 *
 * @param[in] ctx An initialized context
 *
 * This function should be called only once, after all the data has
 * been processed with ktb_hash_process() and before the actual hash
 * value has been retrieved with ktb_hash_retrieve().
 */
Function(RET=const void *,NAME=ktb_hash_retrieve, ktb_hash_ctx_t ctx, size_t size); /** Retrieve the computed hash.
 *
 * @param[in] ctx An initialized context
 * @param[out] size The size of the returned buffer. This can be NULL if the size
 * is already known.
 *
 * @return A pointer to the computed hash value.  The pointer will point to a
 * block of memory of length ktb_hash_get_len() bytes.
 * 
 * @warning This function can only be called after calling ktb_hash_finalise().
 */
Function(RET=const char *,NAME=ktb_hash_get_name, ktb_hash_ctx_t ctx); /** Return a human-readable name of the hash algorithm associated
 * with a given context.
 *
 * @param[in] ctx An initialized context
 *
 * @return A string containing the name of the hash algorithm.
 *
 * @warning The returned string should not be freed or modified in any way.
 * If the string must be modified, make a copy of it and modify the copy.
 */
Function(RET=const char *,NAME=ktb_hash_get_name_from_algo, ktb_hash_algo_t algo); /** Return a human-readable name of the hash algorithm.
 *
 * @param[in] algo The hash algorithm
 *
 * @return A string containing the name of the hash algorithm.
 *
 * @warning The returned string should not fe free()ed or modified in any way.
 */
Function(RET=size_t,NAME=ktb_hash_get_len, ktb_hash_ctx_t ctx); /** Return the length in bytes of the hash value that the given context
 * will produce.
 *
 * @param[in] ctx The context the length of whose hash value we are interested in
 *
 * @return The length in bytes of the hash value produced by @a ctx.
 */
Function(RET=size_t,NAME=ktb_hash_get_len_from_algo, ktb_hash_algo_t algo); /** Return he length in bytes of the hash value that the given
 * algorithm will produce.
 *
 * @param[in] algo An algorithm identifier
 *
 * @return The length in bytes of the hash value produced by a context
 * initialised with @a algo.
 */
Function(RET=size_t,NAME=ktb_hash_get_block_size, ktb_hash_ctx_t ctx); /** Return the length in bytes of the block size of the given context.
 *
 * @param[in] ctx The context whose block size we want.
 *
 * @return The length in bytes of the block size of the hash algorithm associated
 * with @a ctx.
 * 
 * @note Most people will have no use for this function, but we expose it
 * anyway. It's used only in the HMAC code.
 */
Function(RET=ktb_errno,NAME=ktb_hash_block, ktb_hash_algo_t algo, const void *block, size_t block_size, void *result, size_t result_size); /** Hash a block of memory.
 *
 * @param[in] algo The hash algorithm to use.
 * @param[in] block The block of data to hash.
 * @param[in] block_size The length of @a block.
 * @param[out] result The location where the computed hash should be put.
 * @param[in] result_size The length of @a result.
 *
 * @return An error if any step in the hash computation failed, or if 
 * @a result_size is too small to contain the computed hash.
 * 
 * @note
 * @a result must already refer to an available block of memory of
 * at least @a result_size bytes.  Moreover, @a result_size must be at
 * least ktb_hash_get_len_from_algo() bytes long.
 *
 * This function is (roughly) equivalent to the following code:
 * @code
 *     ktb_hash_ctx_t ctx;
 *     ktb_hash_init(&ctx, algo);
 *     ktb_hash_process(ctx, block, blocklen);
 *     ktb_hash_finalise(ctx);
 *     memcpy(result, ktb_hash_retrieve(ctx), result_size);
 *     ktb_hash_clear(ctx);
 * @endcode
 */
Enums:
[enum ktb_hash_algo={KTB_HASH_ALGO_SHA1=0}{KTB_HASH_ALGO_SHA224=1}{KTB_HASH_ALGO_SHA256=2}{KTB_HASH_ALGO_SHA384=3}{KTB_HASH_ALGO_SHA512=4}{KTB_HASH_ALGO_CRC24=5}{KTB_HASH_ALGO_SKEIN256=6}{KTB_HASH_ALGO_SKEIN512=7}{KTB_HASH_ALGO_SKEIN1024=8}{KTB_HASH_ALGO_SHABAL192=9}{KTB_HASH_ALGO_SHABAL224=10}{KTB_HASH_ALGO_SHABAL256=11}{KTB_HASH_ALGO_SHABAL384=12}{KTB_HASH_ALGO_SHABAL512=13}>ktb_hash_algo_t]
Structs:
[struct ktb_hash_ctx>ktb_hash_ctx_t]
Callbacks:
Consts:

. Parsing "curves"
Parsing module "curves"
Creating parser for "Headers/kab/curves.h"
Parsing "Headers/kab/curves.h"...
Setting function name:"ktb_curves_count"
Setting function name:"ktb_curves_id"
Adding parameter:[index:int]
Functions:
Function(RET=int,NAME=ktb_curves_count,void); /** Get the number of available elliptic curves at run-time.
 *
 * This function give the application a way to use a dynamic list of elliptic
 * curves instead of hardcoding which curves to use.
 *
 * @return The number of curves available.
 *
 * @see The function ktb_curves_id() is used to retrieve the actual curves
 * identifiers.
 */
Function(RET=const char *,NAME=ktb_curves_id, int index); /** Return a curve identifier, to be used throughout the KTB.
 *
 * All available curves are identified with a unique null-terminated string.
 * This function make it possible to retrieve those identifiers at run-time,
 * effectively avoiding the need to hardcode them.
 *
 * @param[in] index The curve index. This value must be greater or equal to 0 and
 * less than the value returned bt ktb_curves_count().
 *
 * @return The corresponding curve identifier. The returned value must not be
 * freed, since it is managed by the library.
 */
Enums:
Structs:
Callbacks:
Consts:

. Parsing "base64"
Parsing module "base64"
Creating parser for "Headers/kab/base64.h"
Parsing "Headers/kab/base64.h"...
Setting function name:"ktb_base64_encode_size"
Adding parameter:[input_size:size_t]
Setting function name:"ktb_base64_encode"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Setting function name:"ktb_base64_decode_size"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Setting function name:"ktb_base64_decode"
Adding parameter:[input:const void *]
Adding parameter:[input_size:size_t]
Adding parameter:[result:void *]
Adding parameter:[result_size:size_t]
Functions:
Function(RET=size_t,NAME=ktb_base64_encode_size, size_t input_size); /** Determine the size of a string needed to hold a base64 encoded buffer.
 *
 * @param[in] input_size
 * The size of the buffer to encode
 *
 * @return
 * The size needed to hold the base64 encoded buffer, without the terminal
 * NULL character.
 */
Function(RET=ktb_errno,NAME=ktb_base64_encode, const void *input, size_t input_size, void *result, size_t result_size); /** Convert a byte sequence to a base64-printable string.
 *
 * @param[in] input
 * The input buffer
 *
 * @param[in] input_size
 * The size of the @a input buffer
 *
 * @param[out] result
 * A buffer to hold the converted string. It must be large enough to hold
 * the converted string without the terminating NULL character.
 *
 * @param[in] result_size
 * The size of the @a result buffer. The size needed to hold the encoded
 * string can be retrieved with ktb_base64_encode_size().
 *
 * @retval KTB_ERR_NO_ERROR
 * no error occured
 *
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL 
 * The @a result buffer is too small to hold the converted result
 *
 * @retval KTB_ERR_INVALID_PARAMS 
 * Parameters @a input or @a result is NULL.
 *
 * @note
 * If an error occur, the content of @a result is undefined.
 *
 * @note
 * This function will not set the final NULL character in @a result; it is
 * the responsibility of the caller to do so if needed.
 */
Function(RET=size_t,NAME=ktb_base64_decode_size, const void *input, size_t input_size); /** Return the size of the buffer needed for ktb_base64_decode()
 *
 * @param[in] input
 * The base64 encoded string
 *
 * @param[in] input_size
 * The size of @a input
 *
 * @return
 * The size of the buffer needed to hold the decoded string, or 0 if input
 * is NULL.
 */
Function(RET=ktb_errno,NAME=ktb_base64_decode, const void *input, size_t input_size, void *result, size_t result_size); /** Convert a base64 encoded string into a byte sequence.
 *
 * @param[in] input
 * The source base64 string
 *
 * @param[in] input_size
 * The size of @a input
 *
 * @param[out] result
 * The place to put the decoded sequence. It must be large enough.
 *
 * @param[in] result_size
 * The size of the @a result buffer. The size needed to hold the decoded
 * buffer can be retrieved with ktb_base64_decode_size().
 *
 * @retval KTB_ERR_NO_ERROR
 * success
 *
 * @retval KTB_ERR_DEST_BUFFER_TOO_SMALL 
 * The @a result buffer is too small to hold the result
 *
 * @retval KTB_ERR_INVALID_PARAMS
 * Parameters @a input or @a result is NULL
 *
 * @retval KTB_ERR_DATA_INVALID 
 * Parameter @a input contain invalid data
 *
 * @note
 * If an error occur, the content of @a result is undefined.
 */
Enums:
Structs:
Callbacks:
Consts:

. Parsing "kep_dh"
Parsing module "kep_dh"
Creating parser for "Headers/kep/kep_dh.h"
Parsing "Headers/kep/kep_dh.h"...
Setting struct typedef name:"ktb_kep_dh_t"
Functions:
Enums:
Structs:
[<unnamed>{int dummy}>ktb_kep_dh_t]
Callbacks:
Consts:

. Parsing "kep_dhpass"
Parsing module "kep_dhpass"
Creating parser for "Headers/kep/kep_dhpass.h"
Parsing "Headers/kep/kep_dhpass.h"...
Setting struct typedef name:"ktb_kep_dh_pass_t"
Functions:
Enums:
Structs:
[<unnamed>{ktb_cipher_algo_t cipher_algo, const void *discuss_key, size_t discuss_key_size}>ktb_kep_dh_pass_t]
Callbacks:
Consts:

. Parsing "kep_sts"
Parsing module "kep_sts"
Creating parser for "Headers/kep/kep_sts.h"
Parsing "Headers/kep/kep_sts.h"...
Setting struct typedef name:"ktb_kep_sts_t"
Functions:
Enums:
Structs:
[<unnamed>{ktb_cipher_algo_t cipher_algo, const_ktb_public_key_t peer_public_key, const_ktb_private_key_t self_private_key}>ktb_kep_sts_t]
Callbacks:
Consts:

. Parsing "kep"
Parsing module "kep"
Creating parser for "Headers/kep/kep.h"
Parsing "Headers/kep/kep.h"...
Setting struct name:"struct ktb_kep_algo_t"
Typedef struct is an indirection
Setting struct typedef name:"ktb_kep_algo_data_t"
Setting enum name:"enum ktb_kep_algo"
Adding enum value: [KTB_KEP_ALGO_DH=0]
Adding enum value: [KTB_KEP_ALGO_DH_PASS=1]
Adding enum value: [KTB_KEP_ALGO_STS=2]
Setting enum typedef:"ktb_kep_algo_t"
Setting struct name:"struct ktb_kep_ctx"
Typedef struct is an indirection
Setting struct typedef name:"ktb_kep_ctx_t"
Setting function name:"ktb_kep_init"
Adding parameter:[ctx:ktb_kep_ctx_t *]
Adding parameter:[prng:ktb_prng_t]
Adding parameter:[algo:ktb_kep_algo_t]
Adding parameter:[algo_data:ktb_kep_algo_data_t]
Adding parameter:[algo_data_size:size_t]
Adding parameter:[curve_id:const char *]
Adding parameter:[hash_algo:ktb_hash_algo_t]
Adding parameter:[secret_key_size:size_t]
Adding parameter:[peer_count:int]
Setting function name:"ktb_kep_clear"
Adding parameter:[ctx:ktb_kep_ctx_t]
Setting function name:"ktb_kep_get_data"
Adding parameter:[ctx:ktb_kep_ctx_t]
Adding parameter:[size:size_t *]
Setting function name:"ktb_kep_put_data"
Adding parameter:[ctx:ktb_kep_ctx_t]
Adding parameter:[peer_data:const void *]
Adding parameter:[peer_data_size:size_t]
Adding parameter:[continue_exchange:bool *]
Setting function name:"ktb_kep_finalise"
Adding parameter:[ctx:ktb_kep_ctx_t]
Adding parameter:[secret_key:void *]
Adding parameter:[secret_key_size:size_t]
Setting function name:"ktb_kep_get_algo_name"
Adding parameter:[algo:ktb_kep_algo_t]
Functions:
Function(RET=ktb_errno,NAME=ktb_kep_init, ktb_kep_ctx_t *ctx, ktb_prng_t prng, ktb_kep_algo_t algo, ktb_kep_algo_data_t algo_data, size_t algo_data_size, const char *curve_id, ktb_hash_algo_t hash_algo, size_t secret_key_size, int peer_count); /** Initialize a KEP context.
 *
 * Allocate a new context needed to perform a key exchange, and initialise
 * the protocol.
 *
 * The structure pointed by @a algo_data depends on the algorithm selected
 * with @a algo. See the @ref KEP_indepth page to know which structure must
 * be used with which algorithm.
 *
 * @param[out] ctx The context to initialize.
 * @param[in] prng The PRNG to use to generate the secret key
 * @param[in] algo Algorithm to use for the key exchange
 * @param[in] algo_data Algorithm specific parameters, see @ref KEP_indepth
 * @param[in] algo_data_size Size of the data pointed by @a algo_data
 * @param[in] curve_id The database id of the curve to use in the key
 *                     exchange
 * @param[in] hash_algo The hash algorithm used to generate the secret key
 * @param[in] secret_key_size The size of the secret key to generate
 * @param[in] peer_count The number of peer in this exchange
 *
 * @retval KTB_ERR_NO_ERROR  The context was successfuly initialized
 * @retval KTB_ERR_INVALID_PARAMS An invalid parameters, such as a NULL
 *                                pointer, was passed to the function
 * @retval KTB_ERR_UNKNOWN_KEP_ALGO Invalid algorithm specified
 * @retval KTB_ERR_KEP_TOO_MANY_PEERS The number of peers specified is not
 *                                    supported by the given algorithm
 * @retval KTB_ERR_OUT_OF_MEM An error occured when allocating memory
 *
 * @return  Additionnaly, initialisation error from the underlying algorithm
 * might be returned.
 *
 * @note When an error occur, the context is not allocated, and @a ctx is
 * set to NULL.
 */
Function(RET=void,NAME=ktb_kep_clear, ktb_kep_ctx_t ctx); /** Clear a kep context.
 *
 * This function clean and release all of the memory associated with a kep
 * context. It must be called on all context successfuly initialized with
 * ktb_kep_init(), even when an error occur during the exchange.
 *
 * @param[in] ctx The context created in ktb_kep_init().
 *
 * @note It is possible to call this function on a NULL context without
 * raising an error.
 */
Function(RET=const void *,NAME=ktb_kep_get_data, ktb_kep_ctx_t ctx, size_t *size); /** Return the data to transmit to the next peer.
 *
 * This function is one of the two principal functions used in KEP. Every
 * peer will call it once, transmit the data to the next peer, and wait for
 * input. This process must run in a loop that break when ktb_kep_put_data()
 * return KTB_ERR_KEP_COMPLETED, which mean that this peer don't need to
 * transmit anymore data.
 *
 * @param[in] ctx An initialized context
 * @param[out] size The size of the returned buffer. It can't be NULL, since
 *                  there is no other way to know the size of the returned
 *                  buffer.
 * 
 * @return A pointer to the buffer that need to be transmitted. The size of
 * this buffer is put in @a size. This point to an internal buffer that is
 * handled by the library, so it should not be freed by the application.
 *
 * @note
 * The returned buffer is valid until the next call to ktb_kep_put_data().
 * You must either transmit it's content before the next call to
 * ktb_kep_put_data(), or copy it somewhere else.
 *
 * @note You should call this function only once per "loop"; trying to call
 * it again without calling ktb_kep_put_data() in between will return NULL.
 */
Function(RET=ktb_errno,NAME=ktb_kep_put_data, ktb_kep_ctx_t ctx, const void *peer_data, size_t peer_data_size, bool *continue_exchange); /** Feed data received from the previous peer in the exchange.
 *
 * After having sent the data got from ktb_kep_get_data(), each peer will
 * receive a byte buffer that must be passed to ktb_kep_put_data(). When
 * no errors occurs, there will be exactly the same number of successful
 * calls to ktb_kep_get_data() and ktb_kep_put_data() on each peer.
 *
 * @param[in] ctx An initialized context
 * @param[in] peer_data The data received from the preceding peer
 * @param[in] peer_data_size The size of @a peer_data
 * @param[out] continue_exchange This variable will be set to true if the
 * exchange need to perform another loop of calls to ktb_kep_get_data() and
 * ktb_kep_put_data(). On the last loop iteration, it will be set to false,
 * indicating that the exchange loop can be exited.
 *
 * @retval KTB_ERR_NO_ERROR The input was successfuly consumed
 * @retval KTB_ERR_KEP_COMPLETED The exchange is already complete, and
 *                               didn't expect anymore data.
 * @retval KTB_ERR_INVALID_PARAMS Either @a ctx or @a peer_data or
 *                                @a continue_exchange is NULL
 * @retval KTB_ERR_KEP_NOT_STARVED You tried to call ktb_kep_put_data() but
 *                                 the algorithm expected a call to
 *                                 ktb_kep_get_data() instead
 *
 * @return This function can also return error code from the underlying
 * algorithm (such as @ref KTB_ERR_DATA_INVALID if the content of
 * @a peer_data is invalid)
 *
 * If an error occured, the exchange protocol failed and must be stopped.
 *
 * @note When @a continue_exchange is set to false, it does not mean that
 * the exchange was successful; it is important to check that the return
 * code is also set to @ref KTB_ERR_NO_ERROR .
 */
Function(RET=ktb_errno,NAME=ktb_kep_finalise, ktb_kep_ctx_t ctx, void *secret_key, size_t secret_key_size); /** Complete the exchange.
 *
 * This function will compute the shared secret key.
 *
 * It can be called only once, after the exchange successfuly completed
 * (when ktb_kep_put_data() set it's @a continue_exchange parameter to false
 * and return @ref KTB_ERR_NO_ERROR ).
 *
 * @param[in] ctx An initialized context
 * @param[out] secret_key The place to put the secret key bytes. It must be
 * already allocated and large enough to hold the key length specified
 * in ktb_kep_init().
 * @param[in] secret_key_size The size of the buffer pointed by @a secret_key.
 * It must be large enough to hold the generated secret key.
 * 
 * @retval KTB_ERR_NO_ERROR The shared secret key was generated successfuly
 * @retval KTB_ERR_INVALID_PARAMS @a ctx is NULL
 * @retval KTB_ERR_KEP_INCOMPLETE There is still some exchange to do with
 * ktb_kep_get_data() and ktb_kep_put_data()
 *
 * @return This function can also return error codes from the underlying
 * algorithm.
 */
Function(RET=const char *,NAME=ktb_kep_get_algo_name, ktb_kep_algo_t algo); /**
 * Get the user readable name for an algorithm.
 *
 * @param[in] algo The algorithm identifier
 *
 * @return A null-terminated string representing the algorithm name. This is
 * an internal pointer and must not be freed by the application. If the
 * algorithm doesn't exist, NULL is returned.
 */
Enums:
[enum ktb_kep_algo={KTB_KEP_ALGO_DH=0}{KTB_KEP_ALGO_DH_PASS=1}{KTB_KEP_ALGO_STS=2}>ktb_kep_algo_t]
Structs:
[struct ktb_kep_algo_t>ktb_kep_algo_data_t]
[struct ktb_kep_ctx>ktb_kep_ctx_t]
Callbacks:
Consts:

. Parsing "ktb"
Parsing module "ktb"
Creating parser for "Headers/ktb.h"
Parsing "Headers/ktb.h"...
Setting function name:"ktb_init"
Setting function name:"ktb_clear"
Functions:
Function(RET=ktb_errno,NAME=ktb_init,void); /** Perform the necessary initialisation.
     *
     * This function allocate ressources for the correct operation of the
     * library. It must be called before anything else.
     *
     * @attention
     * Must be called before any other call to the KTB library.
     */
Function(RET=void,NAME=ktb_clear,void); /** Perform any remaining chores needed to ensure a clean exit from the
     * program.
     *
     * @attention
     * Must be called after the last call to the KTB library has been
     * completed.
     */
Enums:
Structs:
Callbacks:
Consts:

]
STEP 2/x Parsing C headers
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : int
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : int
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : int
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : int
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : int
Converting to JNI : int
Size Getter = 1
Size Setter = 1
Size GetterSetter = 4
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : ktb_cipher_algo_t
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : const void *
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : size_t
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : ktb_cipher_algo_t
Converting to Java : long
Converting to Java : const void *
Converting to Java : long
Converting to Java : size_t
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : ktb_cipher_algo_t
Converting to Java : void
Converting to Java : long
Converting to Java : const void *
Converting to Java : void
Converting to Java : long
Converting to Java : size_t
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : long
Converting to JNI : const void *
Converting to JNI : long
Converting to JNI : size_t
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : void
Converting to JNI : long
Converting to JNI : const void *
Converting to JNI : const void *
Converting to JNI : void
Converting to JNI : long
Converting to JNI : size_t
Converting to JNI : size_t
Size Getter = 3
Size Setter = 3
Size GetterSetter = 8
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : ktb_cipher_algo_t
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : const_ktb_public_key_t
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : const_ktb_private_key_t
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
2.4.3.4.7.1
2.4.3.4.7.2
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : ktb_cipher_algo_t
Converting to Java : long
Converting to Java : const_ktb_public_key_t
Converting to Java : long
Converting to Java : const_ktb_private_key_t
Converting to Java : long
Converting to Java : void
Converting to Java : long
Converting to Java : ktb_cipher_algo_t
Converting to Java : void
Converting to Java : long
Converting to Java : const_ktb_public_key_t
Converting to Java : void
Converting to Java : long
Converting to Java : const_ktb_private_key_t
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : long
Converting to JNI : const_ktb_public_key_t
Converting to JNI : long
Converting to JNI : const_ktb_private_key_t
Converting to JNI : long
Converting to JNI : void
Converting to JNI : long
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : void
Converting to JNI : long
Converting to JNI : const_ktb_public_key_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : void
Converting to JNI : long
Converting to JNI : const_ktb_private_key_t
Converting to JNI : const_ktb_private_key_t
Size Getter = 3
Size Setter = 3
Size GetterSetter = 8
modules.size : 16
SaveFctsSize : 0
JNIParser size : 20
JNIParser size : 20
SaveFctsSize : 20
Show Callbacks
This is a init Function
Beta
Type = ktb_sign_ctx_tCall : 0
The first argument type is not Native
The object does not exists = ktb_sign_ctx_t *2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_init
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t *AddressWrapper
Converting to Java : ktb_hash_algo_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t *AddressWrapper
Converting to JNI : ktb_hash_algo_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_clear
Converting to Java : void
Converting to Java : ktb_sign_ctx_t
Converting to JNI : void
Converting to JNI : ktb_sign_ctx_t
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_reset
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_process
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_finalise
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_public_key_t , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_set_public_key
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to Java : const_ktb_public_key_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , signature_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = boolCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , is_valid]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_verify
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : bool *
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : bool *
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_public_key_t , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , signature_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = boolCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , is_valid]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_verify_block
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : const_ktb_public_key_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : bool *
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : bool *
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_private_key_t , private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_set_private_key
Converting to Java : ktb_errno
Converting to Java : ktb_sign_ctx_t
Converting to Java : const_ktb_private_key_t
Converting to Java : ktb_prng_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : const_ktb_private_key_t
Converting to JNI : ktb_prng_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_get_sign_size
Converting to Java : size_t
Converting to Java : ktb_sign_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_sign_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = size_tCall : 0
Native Type pointer 
The object does not exists = size_t *Creating a new Param as following[Address Wrapper , size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_get_sign
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : ktb_sign_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : ktb_sign_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[const_ktb_private_key_t , private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_get_sign_size_from_key
Converting to Java : size_t
Converting to Java : const_ktb_private_key_t
Converting to JNI : size_t
Converting to JNI : const_ktb_private_key_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_private_key_t , private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , signature_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_sign_sign_block
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : ktb_prng_t
Converting to Java : const_ktb_private_key_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : ktb_prng_t
Converting to JNI : const_ktb_private_key_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Java
1
Nom du module : sign
2
Show Callbacks
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , seed_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , derived_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kdf
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , passwd_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , salt_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[size_t , iteration_count]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , derived_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_pbkdf
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : const void *
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kdf_max_size
Converting to Java : size_t
Converting to Java : ktb_hash_algo_t
Converting to JNI : size_t
Converting to JNI : ktb_hash_algo_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Java
1
Nom du module : kdf
2
Show Callbacks
Normal Type
Creating a new Param as following[ktb_errno , err]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Create an Array
2.4.3.4.7.1
2.4.3.4.7.2
charArray
Normal Type
Creating a new Param as following[size_t , buf_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_strerror
Converting to Java : int
Converting to Java : ktb_errno
Converting to Java : charArray
Converting to Java : char
Converting to Java : size_t
Converting to JNI : int
Converting to JNI : ktb_errno
Converting to JNI : charArray
Converting to JNI : char
Converting to JNI : size_t
Converting to JNI : int
Converting to JNI : char
Converting to JNI : int
Converting to JNI : int
Converting to JNI : char
Java
1
Nom du module : err
2
Show Callbacks
Normal Type
Creating a new Param as following[const_ktb_public_key_t , peer_public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kem_psec_encrypt_size
Converting to Java : size_t
Converting to Java : const_ktb_public_key_t
Converting to JNI : size_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_public_key_t , peer_public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , secret_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , ciphertext_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kem_psec_encrypt
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : ktb_prng_t
Converting to Java : const_ktb_public_key_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : ktb_prng_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const_ktb_private_key_t , self_private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_ciphertext_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , secret_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kem_psec_decrypt
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : const_ktb_private_key_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const_ktb_private_key_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Java
1
Nom du module : kem
2
Show Callbacks
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_prng_clear
Converting to Java : void
Converting to Java : ktb_prng_t
Converting to JNI : void
Converting to JNI : ktb_prng_t
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , buffer_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_prng_reseed_with
Converting to Java : ktb_errno
Converting to Java : ktb_prng_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_prng_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_prng_reseed
Converting to Java : ktb_errno
Converting to Java : ktb_prng_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_prng_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , buffer_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_prng_fill_buffer
Converting to Java : ktb_errno
Converting to Java : ktb_prng_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_prng_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Java
1
Nom du module : prng
2
Show Callbacks
Normal Type
Creating a new Param as following[ktb_public_key_t , key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_public_key_clear
Converting to Java : void
Converting to Java : ktb_public_key_t
Converting to JNI : void
Converting to JNI : ktb_public_key_t
Normal Type
Creating a new Param as following[ktb_private_key_t , key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_private_key_clear
Converting to Java : void
Converting to Java : ktb_private_key_t
Converting to JNI : void
Converting to JNI : ktb_private_key_t
Normal Type
Creating a new Param as following[const_ktb_public_key_t , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_public_key_export_size
Converting to Java : size_t
Converting to Java : const_ktb_public_key_t
Converting to JNI : size_t
Converting to JNI : const_ktb_public_key_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[const_ktb_public_key_t , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_public_key_export
Converting to Java : ktb_errno
Converting to Java : const_ktb_public_key_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const_ktb_public_key_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , public_key_bytes_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = ktb_public_key_tCall : 0
This is not a Native Type = ktb_public_key_t
The object does not exists = ktb_public_key_t *Creating a new Param as following[Address Wrapper , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_public_key_import
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : ktb_public_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_public_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[const_ktb_private_key_t , key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_private_key_export_size
Converting to Java : size_t
Converting to Java : const_ktb_private_key_t
Converting to JNI : size_t
Converting to JNI : const_ktb_private_key_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[const_ktb_private_key_t , key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , buffer_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_private_key_export
Converting to Java : ktb_errno
Converting to Java : const_ktb_private_key_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const_ktb_private_key_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , private_key_bytes_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = ktb_private_key_tCall : 0
This is not a Native Type = ktb_private_key_t
The object does not exists = ktb_private_key_t *Creating a new Param as following[Address Wrapper , private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_private_key_import
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : ktb_private_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_private_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const char * , curve_id]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = ktb_public_key_tCall : 0
This is not a Native Type = ktb_public_key_t
Creating a new Param as following[Address Wrapper , public_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = ktb_private_key_tCall : 0
This is not a Native Type = ktb_private_key_t
Creating a new Param as following[Address Wrapper , private_key]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_keys_generate_keypair
Converting to Java : ktb_errno
Converting to Java : ktb_prng_t
Converting to Java : const char *
Converting to Java : ktb_public_key_t *AddressWrapper
Converting to Java : ktb_private_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : ktb_prng_t
Converting to JNI : const char *
Converting to JNI : ktb_public_key_t *AddressWrapper
Converting to JNI : ktb_private_key_t *AddressWrapper
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Java
1
Nom du module : keys
2
Show Callbacks
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_radix64_encode_size
Converting to Java : size_t
Converting to Java : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_radix64_encode
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_radix64_decode_size
Converting to Java : size_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : const void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_radix64_decode
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = boolCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , verified]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_radix64_verify
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : bool *
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : bool *
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Java
1
Nom du module : radix64
2
Show Callbacks
This is a init Function
Beta
Type = ktb_cipher_ctx_tCall : 0
The first argument type is not Native
The object does not exists = ktb_cipher_ctx_t *2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[ktb_cipher_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_cipher_mode_t , mode]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[bool , encryption]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_init
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t *AddressWrapper
Converting to Java : ktb_cipher_algo_t
Converting to Java : ktb_cipher_mode_t
Converting to Java : bool
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t *AddressWrapper
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : ktb_cipher_mode_t
Converting to JNI : bool
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_clear
Converting to Java : void
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : void
Converting to JNI : ktb_cipher_ctx_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_reset
Converting to Java : void
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : void
Converting to JNI : ktb_cipher_ctx_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_set_key
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , iv_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_set_iv
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , auth_data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_set_auth_data
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_prefix_size
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , prefix_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_prefix
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , prefix_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_set_prefix
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_suffix_size
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , suffix_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_suffix
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , in_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , out_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_encrypt_block
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , in_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , out_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_decrypt_block
Converting to Java : ktb_errno
Converting to Java : ktb_cipher_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_finalise
Converting to Java : void
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : void
Converting to JNI : ktb_cipher_ctx_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = size_tCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_mac
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_data_size
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_name_from_algo
Converting to Java : const char *
Converting to Java : ktb_cipher_algo_t
Converting to JNI : const char *
Converting to JNI : ktb_cipher_algo_t
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Normal Type
Creating a new Param as following[ktb_cipher_mode_t , mode]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_name_from_mode
Converting to Java : const char *
Converting to Java : ktb_cipher_mode_t
Converting to JNI : const char *
Converting to JNI : ktb_cipher_mode_t
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_key_len
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_block_len
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_iv_len
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_mac_size
Converting to Java : size_t
Converting to Java : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_cipher_mode_t , mode]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_cipher_get_iv_len_from_mode
Converting to Java : size_t
Converting to Java : ktb_cipher_mode_t
Converting to JNI : size_t
Converting to JNI : ktb_cipher_mode_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Java
1
Nom du module : cipher
2
Show Callbacks
This is a init Function
Beta
Type = ktb_hash_ctx_tCall : 0
The first argument type is not Native
The object does not exists = ktb_hash_ctx_t2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_init
Converting to Java : ktb_errno
Converting to Java : ktb_hash_ctx_tAddressWrapper
Converting to Java : ktb_hash_algo_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_ctx_tAddressWrapper
Converting to JNI : ktb_hash_algo_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
This is a init Function
Beta
Type = ktb_hash_ctx_tCall : 0
The first argument type is not Native
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_init_hmac
Converting to Java : ktb_errno
Converting to Java : ktb_hash_ctx_tAddressWrapper
Converting to Java : ktb_hash_algo_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_ctx_tAddressWrapper
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_clear
Converting to Java : void
Converting to Java : ktb_hash_ctx_t
Converting to JNI : void
Converting to JNI : ktb_hash_ctx_t
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_reset
Converting to Java : void
Converting to Java : ktb_hash_ctx_t
Converting to JNI : void
Converting to JNI : ktb_hash_ctx_t
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , buf_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_process
Converting to Java : void
Converting to Java : ktb_hash_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : void
Converting to JNI : ktb_hash_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_finalise
Converting to Java : void
Converting to Java : ktb_hash_ctx_t
Converting to JNI : void
Converting to JNI : ktb_hash_ctx_t
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[size_t , size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_retrieve
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : ktb_hash_ctx_t
Converting to Java : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : ktb_hash_ctx_t
Converting to JNI : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_get_name
Converting to Java : const char *
Converting to Java : ktb_hash_ctx_t
Converting to JNI : const char *
Converting to JNI : ktb_hash_ctx_t
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_get_name_from_algo
Converting to Java : const char *
Converting to Java : ktb_hash_algo_t
Converting to JNI : const char *
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_get_len
Converting to Java : size_t
Converting to Java : ktb_hash_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_hash_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_get_len_from_algo
Converting to Java : size_t
Converting to Java : ktb_hash_algo_t
Converting to JNI : size_t
Converting to JNI : ktb_hash_algo_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_hash_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_get_block_size
Converting to Java : size_t
Converting to Java : ktb_hash_ctx_t
Converting to JNI : size_t
Converting to JNI : ktb_hash_ctx_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Normal Type
Creating a new Param as following[ktb_hash_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , block_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_hash_block
Converting to Java : ktb_errno
Converting to Java : ktb_hash_algo_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_hash_algo_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Java
1
Nom du module : hash
2
Show Callbacks
Converting Function : ktb_curves_count
Converting to Java : int
Converting to JNI : int
Converting to JNI : int
Converting to JNI : int
Converting to JNI : int
Normal Type
Creating a new Param as following[int , index]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_curves_id
Converting to Java : const char *
Converting to Java : int
Converting to JNI : const char *
Converting to JNI : int
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Java
1
Nom du module : curves
2
Show Callbacks
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_base64_encode_size
Converting to Java : size_t
Converting to Java : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : size_t
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_base64_encode
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_base64_decode_size
Converting to Java : size_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to JNI : size_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : size_t
Converting to JNI : const void *
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , input_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , result_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_base64_decode
Converting to Java : ktb_errno
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : void *
Java
1
Nom du module : base64
2
Show Callbacks
Java
1
Nom du module : kep_dh
2
Show Callbacks
Java
1
Nom du module : kep_dhpass
2
Show Callbacks
Java
1
Nom du module : kep_sts
2
Show Callbacks
This is a init Function
Beta
Type = ktb_kep_ctx_tCall : 0
The first argument type is not Native
The object does not exists = ktb_kep_ctx_t *2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[ktb_prng_t , prng]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_kep_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_kep_algo_data_t , algo_data]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[size_t , algo_data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[const char * , curve_id]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[ktb_hash_algo_t , hash_algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[size_t , secret_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Normal Type
Creating a new Param as following[int , peer_count]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_init
Converting to Java : ktb_errno
Converting to Java : ktb_kep_ctx_t *AddressWrapper
Converting to Java : ktb_prng_t
Converting to Java : ktb_kep_algo_t
Converting to Java : ktb_kep_algo_data_t
Converting to Java : size_t
Converting to Java : const char *
Converting to Java : ktb_hash_algo_t
Converting to Java : size_t
Converting to Java : int
Converting to JNI : ktb_errno
Converting to JNI : ktb_kep_ctx_t *AddressWrapper
Converting to JNI : ktb_prng_t
Converting to JNI : ktb_kep_algo_t
Converting to JNI : ktb_kep_algo_data_t
Converting to JNI : size_t
Converting to JNI : const char *
Converting to JNI : ktb_hash_algo_t
Converting to JNI : size_t
Converting to JNI : int
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Normal Type
Creating a new Param as following[ktb_kep_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_clear
Converting to Java : void
Converting to Java : ktb_kep_ctx_t
Converting to JNI : void
Converting to JNI : ktb_kep_ctx_t
Normal Type
Creating a new Param as following[ktb_kep_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = size_tCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_get_data
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : ktb_kep_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : ktb_kep_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_kep_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , peer_data_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Beta
Type = boolCall : 0
Native Type pointer 
Creating a new Param as following[Address Wrapper , continue_exchange]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_put_data
Converting to Java : ktb_errno
Converting to Java : ktb_kep_ctx_t
Converting to Java : const void *Array
Converting to Java : const void *
Converting to Java : size_t
Converting to Java : bool *
Converting to JNI : ktb_errno
Converting to JNI : ktb_kep_ctx_t
Converting to JNI : const void *Array
Converting to JNI : const void *
Converting to JNI : size_t
Converting to JNI : bool *
Converting to JNI : ktb_errno
Converting to JNI : const void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : const void *
Normal Type
Creating a new Param as following[ktb_kep_ctx_t , ctx]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Pointer !
Const void* or void* array
2.4.3.4.7.1
2.4.3.4.7.2
Normal Type
Creating a new Param as following[size_t , secret_key_size]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_finalise
Converting to Java : ktb_errno
Converting to Java : ktb_kep_ctx_t
Converting to Java : void *Array
Converting to Java : void *
Converting to Java : size_t
Converting to JNI : ktb_errno
Converting to JNI : ktb_kep_ctx_t
Converting to JNI : void *Array
Converting to JNI : void *
Converting to JNI : size_t
Converting to JNI : ktb_errno
Converting to JNI : void *
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : void *
Normal Type
Creating a new Param as following[ktb_kep_algo_t , algo]
2.4.3.4.7.1
2.4.3.4.7.2
Fin Fonction
Converting Function : ktb_kep_get_algo_name
Converting to Java : const char *
Converting to Java : ktb_kep_algo_t
Converting to JNI : const char *
Converting to JNI : ktb_kep_algo_t
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Converting to JNI : const char *
Java
1
Nom du module : kep
2
Show Callbacks
Converting Function : ktb_init
Converting to Java : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting to JNI : ktb_errno
Converting Function : ktb_clear
Converting to Java : void
Converting to JNI : void
Java
1
Nom du module : ktb
2
Nombre de Modules = 16
